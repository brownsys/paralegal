<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of a data-race detector using Lamport Timestamps / Vector-clocks based on the Dynamic Race Detection for C++: https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf which does not report false-positives when fences are used, and gives better accuracy in presence of read-modify-write operations."><title>miri::concurrency::data_race - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="miri" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0-nightly (0aeaa5eb2 2024-12-14)" data-channel="nightly" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../miri/index.html">miri</a><span class="version">1.85.0-nightly</span></h2></div><div class="version">(0aeaa5eb2	2024-12-14)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module data_<wbr>race</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In miri::<wbr>concurrency</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">miri</a>::<wbr><a href="../index.html">concurrency</a></span><h1>Module <span>data_race</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/miri/concurrency/data_race.rs.html#1-1876">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of a data-race detector using Lamport Timestamps / Vector-clocks
based on the Dynamic Race Detection for C++:
<a href="https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf">https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf</a>
which does not report false-positives when fences are used, and gives better
accuracy in presence of read-modify-write operations.</p>
<p>The implementation contains modifications to correctly model the changes to the memory model in C++20
regarding the weakening of release sequences: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html</a>.
Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release
sequences is not needed.</p>
<p>The implementation also models races with memory allocation and deallocation via treating allocation and
deallocation as a type of write internally for detecting data-races.</p>
<p>Weak memory orders are explored but not all weak behaviours are exhibited, so it can still miss data-races
but should not report false-positives</p>
<p>Data-race definition from(<a href="https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races">https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races</a>):
a data race occurs between two memory accesses if they are on different threads, at least one operation
is non-atomic, at least one operation is a write and neither access happens-before the other. Read the link
for full definition.</p>
<p>This re-uses vector indexes for threads that are known to be unable to report data-races, this is valid
because it only re-uses vector indexes once all currently-active (not-terminated) threads have an internal
vector clock that happens-after the join operation of the candidate thread. Threads that have not been joined
on are not considered. Since the threadâ€™s vector clock will only increase and a data-race implies that
there is some index x where <code>clock[x] &gt; thread_clock</code>, when this is true <code>clock[candidate-idx] &gt; thread_clock</code>
can never hold and hence a data-race can never be reported in that vector index again.
This means that the thread-index can be safely re-used, starting on the next timestamp for the newly created
thread.</p>
<p>The timestamps used in the data-race detector assign each sequence of non-atomic operations
followed by a single atomic or concurrent operation a single timestamp.
Write, Read, Write, ThreadJoin will be represented by a single timestamp value on a thread.
This is because extra increment operations between the operations in the sequence are not
required for accurate reporting of data-race values.</p>
<p>As per the paper a threads timestamp is only incremented after a release operation is performed
so some atomic operations that only perform acquires do not increment the timestamp. Due to shared
code some atomic operations may increment the timestamp when not necessary but this has no effect
on the data-race detection code.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AtomicMemoryCellClocks.html" title="struct miri::concurrency::data_race::AtomicMemoryCellClocks">Atomic<wbr>Memory<wbr>Cell<wbr>Clocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Externally stored memory cell clocks
explicitly to reduce memory usage for the
common case where no atomic operations
exists on the memory cell.</div></li><li><div class="item-name"><a class="struct" href="struct.DataRace.html" title="struct miri::concurrency::data_race::DataRace">Data<wbr>Race</a></div><div class="desc docblock-short">Error returned by finding a data race
should be elaborated upon.</div></li><li><div class="item-name"><a class="struct" href="struct.FrameState.html" title="struct miri::concurrency::data_race::FrameState">Frame<wbr>State</a></div><div class="desc docblock-short">Vector clock state for a stack frame (tracking the local variables
that do not have an allocation yet).</div></li><li><div class="item-name"><a class="struct" href="struct.GlobalState.html" title="struct miri::concurrency::data_race::GlobalState">Global<wbr>State</a></div><div class="desc docblock-short">Global data-race detection state, contains the currently
executing thread as well as the vector-clocks associated
with each of the threads.</div></li><li><div class="item-name"><a class="struct" href="struct.LocalClocks.html" title="struct miri::concurrency::data_race::LocalClocks">Local<wbr>Clocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Stripped-down version of <a href="struct.MemoryCellClocks.html" title="struct miri::concurrency::data_race::MemoryCellClocks"><code>MemoryCellClocks</code></a> for the clocks we need to keep track
of in a local that does not yet have addressable memory â€“ and hence can only
be accessed from the thread its stack frame belongs to, and cannot be access atomically.</div></li><li><div class="item-name"><a class="struct" href="struct.MemoryCellClocks.html" title="struct miri::concurrency::data_race::MemoryCellClocks">Memory<wbr>Cell<wbr>Clocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Per-byte vector clock metadata for data-race detection.</div></li><li><div class="item-name"><a class="struct" href="struct.ThreadClockSet.html" title="struct miri::concurrency::data_race::ThreadClockSet">Thread<wbr>Clock<wbr>Set</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">The current set of vector clocks describing the state
of a thread, contains the happens-before clock and
additional metadata to model atomic fence operations.</div></li><li><div class="item-name"><a class="struct" href="struct.ThreadExtraState.html" title="struct miri::concurrency::data_race::ThreadExtraState">Thread<wbr>Extra<wbr>State</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Extra metadata associated with a thread.</div></li><li><div class="item-name"><a class="struct" href="struct.VClockAlloc.html" title="struct miri::concurrency::data_race::VClockAlloc">VClock<wbr>Alloc</a></div><div class="desc docblock-short">Vector clock metadata for a logical memory allocation.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AccessType.html" title="enum miri::concurrency::data_race::AccessType">Access<wbr>Type</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="enum" href="enum.AtomicAccessType.html" title="enum miri::concurrency::data_race::AtomicAccessType">Atomic<wbr>Access<wbr>Type</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="enum" href="enum.AtomicFenceOrd.html" title="enum miri::concurrency::data_race::AtomicFenceOrd">Atomic<wbr>Fence<wbr>Ord</a></div><div class="desc docblock-short">Valid atomic fence orderings, subset of atomic::Ordering.</div></li><li><div class="item-name"><a class="enum" href="enum.AtomicReadOrd.html" title="enum miri::concurrency::data_race::AtomicReadOrd">Atomic<wbr>Read<wbr>Ord</a></div><div class="desc docblock-short">Valid atomic read orderings, subset of atomic::Ordering.</div></li><li><div class="item-name"><a class="enum" href="enum.AtomicRwOrd.html" title="enum miri::concurrency::data_race::AtomicRwOrd">Atomic<wbr>RwOrd</a></div><div class="desc docblock-short">Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).</div></li><li><div class="item-name"><a class="enum" href="enum.AtomicWriteOrd.html" title="enum miri::concurrency::data_race::AtomicWriteOrd">Atomic<wbr>Write<wbr>Ord</a></div><div class="desc docblock-short">Valid atomic write orderings, subset of atomic::Ordering.</div></li><li><div class="item-name"><a class="enum" href="enum.NaReadType.html" title="enum miri::concurrency::data_race::NaReadType">NaRead<wbr>Type</a></div><div class="desc docblock-short">Type of a non-atomic read operation.</div></li><li><div class="item-name"><a class="enum" href="enum.NaWriteType.html" title="enum miri::concurrency::data_race::NaWriteType">NaWrite<wbr>Type</a></div><div class="desc docblock-short">Type of a non-atomic write operation: allocating memory, non-atomic writes, and
deallocating memory are all treated as writes for the purpose of the data-race detector.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.EvalContextExt.html" title="trait miri::concurrency::data_race::EvalContextExt">Eval<wbr>Context<wbr>Ext</a></div></li><li><div class="item-name"><a class="trait" href="trait.EvalContextPrivExt.html" title="trait miri::concurrency::data_race::EvalContextPrivExt">Eval<wbr>Context<wbr>Priv<wbr>Ext</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.AllocState.html" title="type miri::concurrency::data_race::AllocState">Alloc<wbr>State</a></div></li></ul></section></div></main></body></html>