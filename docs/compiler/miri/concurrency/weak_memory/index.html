<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of C++11-consistent weak memory emulation using store buffers based on Dynamic Race Detection for C++ (‚Äúthe paper‚Äù): https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf"><title>miri::concurrency::weak_memory - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="miri" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0-nightly (0aeaa5eb2 2024-12-14)" data-channel="nightly" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../miri/index.html">miri</a><span class="version">1.85.0-nightly</span></h2></div><div class="version">(0aeaa5eb2	2024-12-14)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module weak_<wbr>memory</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In miri::<wbr>concurrency</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">miri</a>::<wbr><a href="../index.html">concurrency</a></span><h1>Module <span>weak_memory</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/miri/concurrency/weak_memory.rs.html#1-586">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of C++11-consistent weak memory emulation using store buffers
based on Dynamic Race Detection for C++ (‚Äúthe paper‚Äù):
<a href="https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf">https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf</a></p>
<p>This implementation will never generate weak memory behaviours forbidden by the C++11 model,
but it is incapable of producing all possible weak behaviours allowed by the model. There are
certain weak behaviours observable on real hardware but not while using this.</p>
<p>Note that this implementation does not fully take into account of C++20‚Äôs memory model revision to SC accesses
and fences introduced by P0668 (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html</a>).
This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20
disallows (<a href="https://github.com/rust-lang/miri/issues/2301">https://github.com/rust-lang/miri/issues/2301</a>).</p>
<p>Modifications are made to the paper‚Äôs model to address C++20 changes:</p>
<ul>
<li>If an SC load reads from an atomic store of any ordering, then a later SC load cannot read
from an earlier store in the location‚Äôs modification order. This is to prevent creating a
backwards S edge from the second load to the first, as a result of C++20‚Äôs coherence-ordered
before rules. (This seems to rule out behaviors that were actually permitted by the RC11 model
that C++20 intended to copy (<a href="https://plv.mpi-sws.org/scfix/paper.pdf">https://plv.mpi-sws.org/scfix/paper.pdf</a>); a change was
introduced when translating the math to English. According to Viktor Vafeiadis, this
difference is harmless. So we stick to what the standard says, and allow fewer behaviors.)</li>
<li>SC fences are treated like AcqRel RMWs to a global clock, to ensure they induce enough
synchronization with the surrounding accesses. This rules out legal behavior, but it is really
hard to be more precise here.</li>
</ul>
<p>Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++‚Äôs
<code>std::atomic&lt;T&gt;</code> API). It is therefore possible for this implementation to generate behaviours never observable when the
same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes
an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is
A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (<a href="https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf">https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf</a>)
However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).</p>
<p>If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust‚Äôs atomic accesses
and fences accept, and is implementable (with operational semantics), please open a GitHub issue!</p>
<p>One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in
Taming Release-Acquire Consistency by Ori Lahav et al. (<a href="https://plv.mpi-sws.org/sra/paper.pdf">https://plv.mpi-sws.org/sra/paper.pdf</a>) or Promising Semantics noted above,
is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location
and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record
information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.
Additionally, writes in our implementation do not have globally unique timestamps attached. In the other two models this timestamp is
used to make sure a value in a thread‚Äôs view is not overwritten by a write that occurred earlier than the one in the existing view.
In our implementation, this is detected using read information attached to store elements, as there is no data structure representing reads.</p>
<p>The C++ memory model is built around the notion of an ‚Äòatomic object‚Äô, so it would be natural
to attach store buffers to atomic objects. However, Rust follows LLVM in that it only has
‚Äòatomic accesses‚Äô. Therefore Miri cannot know when and where atomic ‚Äòobjects‚Äô are being
created or destroyed, to manage its store buffers. Instead, we hence lazily create an
atomic object on the first atomic write to a given region, and we destroy that object
on the next non-atomic or imperfectly overlapping atomic write to that region.
These lazy (de)allocations happen in memory_accessed() on non-atomic accesses, and
get_or_create_store_buffer_mut() on atomic writes.</p>
<p>One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations
than the C++20 atomic API was intended to allow, such as non-atomically accessing
a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation
(such as accessing the top 16 bits of an AtomicU32). These scenarios are generally undiscussed in formalizations of C++ memory model.
In Rust, these operations can only be done through a <code>&amp;mut AtomicFoo</code> reference or one derived from it, therefore these operations
can only happen after all previous accesses on the same locations. This implementation is adapted to allow these operations.
A mixed atomicity read that races with writes, or a write that races with reads or writes will still cause UBs to be thrown.
Mixed size atomic accesses must not race with any other atomic access, whether read or write, or a UB will be thrown.
You can refer to test cases in weak_memory/extra_cpp.rs and weak_memory/extra_cpp_unsafe.rs for examples of these operations.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.LoadInfo.html" title="struct miri::concurrency::weak_memory::LoadInfo">Load<wbr>Info</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="struct" href="struct.StoreBuffer.html" title="struct miri::concurrency::weak_memory::StoreBuffer">Store<wbr>Buffer</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="struct" href="struct.StoreBufferAlloc.html" title="struct miri::concurrency::weak_memory::StoreBufferAlloc">Store<wbr>Buffer<wbr>Alloc</a></div></li><li><div class="item-name"><a class="struct" href="struct.StoreElement.html" title="struct miri::concurrency::weak_memory::StoreElement">Store<wbr>Element</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.LoadRecency.html" title="enum miri::concurrency::weak_memory::LoadRecency">Load<wbr>Recency</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Whether a load returned the latest value or not.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.STORE_BUFFER_LIMIT.html" title="constant miri::concurrency::weak_memory::STORE_BUFFER_LIMIT">STORE_<wbr>BUFFER_<wbr>LIMIT</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.EvalContextExt.html" title="trait miri::concurrency::weak_memory::EvalContextExt">Eval<wbr>Context<wbr>Ext</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.AllocState.html" title="type miri::concurrency::weak_memory::AllocState">Alloc<wbr>State</a></div></li></ul></section></div></main></body></html>