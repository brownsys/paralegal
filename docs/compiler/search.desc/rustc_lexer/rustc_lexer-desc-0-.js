searchState.loadedDescShard("rustc_lexer", 0, "Low-level Rust lexer.\n<code>&amp;</code>\n<code>@</code>\n<code>!</code>\nBase of numeric literal encoding according to its prefix.\nLiteral starts with “0b”.\nA block comment, e.g. <code>/* block comment */</code>.\n<code>b&#39;a&#39;</code>, <code>b&#39;\\\\&#39;</code>, <code>b&#39;&#39;&#39;</code>, <code>b&#39;;</code>\n<code>b&quot;abc&quot;</code>, <code>b&quot;abc</code>\n<code>c&quot;abc&quot;</code>, <code>c&quot;abc</code>\n<code>^</code>\n<code>&#39;a&#39;</code>, <code>&#39;\\\\&#39;</code>, <code>&#39;&#39;&#39;</code>, <code>&#39;;</code>\n<code>}</code>\n<code>]</code>\n<code>)</code>\n<code>:</code>\n<code>,</code>\nPeekable iterator over a char sequence.\nLiteral doesn’t contain a prefix.\n<code>$</code>\n<code>.</code>\nEnd of input.\n<code>=</code>\n<code>12.34f32</code>, <code>1e3</code>, but not <code>1f32</code>.\n<code>&gt;</code>\n<code>#&quot;abc&quot;#</code>, <code>##&quot;a&quot;</code> (fewer closing), or even <code>#&quot;a</code> (unterminated).\nGuarded string literal prefix: <code>#&quot;</code> or <code>##</code>.\nLiteral starts with “0x”.\nAn identifier or keyword, e.g. <code>ident</code> or <code>continue</code>.\n<code>12_u8</code>, <code>0o100</code>, <code>0b120i99</code>, <code>1f32</code>.\nAn identifier that is invalid because it contains emoji.\nNon <code>#</code> characters exist between <code>r</code> and <code>&quot;</code>, e.g. <code>r##~&quot;abcde&quot;##</code>\nA lifetime, e.g. <code>&#39;a</code>.\nA line comment, e.g. <code>// comment</code>.\nLiterals, e.g. <code>12u8</code>, <code>1.0e-40</code>, <code>b&quot;123&quot;</code>. Note that <code>_</code> is an …\nEnum representing the literal types supported by the lexer.\n<code>&lt;</code>\n<code>-</code>\nThe string was not terminated, e.g. <code>r###&quot;abcde&quot;##</code>. …\nLiteral starts with “0o”.\n<code>{</code>\n<code>[</code>\n<code>(</code>\n<code>|</code>\n<code>%</code>\n<code>+</code>\n<code>#</code>\n<code>?</code>\n<code>br&quot;abc&quot;</code>, <code>br#&quot;abc&quot;#</code>, <code>br####&quot;ab&quot;###&quot;c&quot;####</code>, <code>br#&quot;a</code>. <code>None</code> …\n<code>cr&quot;abc&quot;</code>, “cr#“abc”#“, <code>cr#&quot;a</code>. <code>None</code> indicates an …\nA raw identifier, e.g. “r#ident”.\nA raw lifetime, e.g. <code>&#39;r#foo</code>. In edition &lt; 2021 it will be …\n<code>r&quot;abc&quot;</code>, <code>r#&quot;abc&quot;#</code>, <code>r####&quot;ab&quot;###&quot;c&quot;####</code>, <code>r#&quot;a</code>. <code>None</code> indicates\n<code>;</code>\n<code>/</code>\n<code>*</code>\n<code>&quot;abc&quot;</code>, <code>&quot;abc</code>\n<code>~</code>\nParsed token. It doesn’t contain information about data …\nEnum representing common lexeme types.\nMore than 255 <code>#</code>s exist.\nThe version of Unicode that this version of unicode-xid is …\nUnknown token, not expected by the lexer, e.g. “№”\nAn unknown literal prefix, like <code>foo#</code>, <code>foo&#39;</code>, <code>foo&quot;</code>. Excludes …\nAn unknown prefix in a lifetime, like <code>&#39;foo#</code>.\nAny whitespace character sequence.\nIterator over chars. Slightly faster than a &amp;str.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if <code>c</code> is valid as a non-first character of an …\nTrue if <code>c</code> is valid as a first character of an identifier. …\nThe passed string is lexically an identifier.\nTrue if <code>c</code> is considered a whitespace according to Rust …\n<code>rustc</code> allows files to have a shebang, e.g. “…\nCreates an iterator that produces tokens from the input …\nUtilities for validating string and char literals and …\nValidates a raw string literal. Used for getting more …\nPeekable iterator over a char sequence.\nParses a token from the input string.\nMoves to the next character.\nIterator over chars. Slightly faster than a &amp;str.\nEats double-quoted string and returns true if string is …\nEats the float exponent. Returns true if at least one …\nEats symbols while predicate returns true or until the end …\nPeeks the next symbol from the input stream without …\nReturns the argument unchanged.\nAttempt to lex for a guarded string literal.\nCalls <code>U::from(self)</code>.\nChecks if there is nothing more to consume.\nReturns amount of already consumed symbols.\nReturns the last eaten symbol (or <code>&#39;\\0&#39;</code> in release builds). …\nEats the double-quoted string and returns <code>n_hashes</code> and an …\nResets the number of bytes consumed to 0.\nPeeks the second symbol from the input stream without …\nPeeks the third symbol from the input stream without …\nRaw ‘\\r’ encountered.\nRaw ‘\\r’ encountered in raw string.\nUsed for ASCII chars (written directly or via <code>\\x00</code>..<code>\\x7f</code> …\n‘\\u{}’\nErrors and warnings that can occur during string …\nUnescaped character that was expected to be escaped (e.g. …\nUsed for high bytes (<code>\\x80</code>..<code>\\xff</code>).\nInvalid character in numeric escape (e.g. ‘\\xz’)\nNon-hexadecimal value in ‘\\u{..}’.\nInvalid escape character (e.g. ‘\\z’).\n‘\\u{_12}’\nEscaped ’&#39; character without continuation.\nInvalid in-bound unicode character code, e.g. ‘\\u{DFFF}…\nUsed for mixed utf8 string literals, i.e. those that allow …\nWhat kind of literal do we parse.\nExpected 1 char, but more than 1 were found.\nAfter a line ending with ’&#39;, multiple lines are skipped.\n‘\\u’ not followed by ‘{’.\nNon-ascii character in byte literal, byte string literal, …\nCharacter code in numeric escape is non-ascii (e.g. ‘\\xFF…\nOut of bounds unicode character code, e.g. ‘\\u{FFFFFF}’…\nMore than 6 characters in ‘\\u{..}’, e.g. ‘…\nNumeric character escape is too short (e.g. ‘\\x1’).\nNo closing brace in ‘\\u{..}’, e.g. ‘\\u{12’.\nUnicode escape code in byte literal.\nAfter a line ending with ’&#39;, the next line contains …\nExpected 1 char, but 0 were found.\nAre <code>\\x80</code>..<code>\\xff</code> allowed?\nAre unicode (non-ASCII) chars allowed?\nAre unicode escapes (<code>\\u</code>) allowed?\nTakes a contents of a string literal (without quotes) and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true for actual errors, as opposed to warnings.\nTakes a contents of a byte literal (without quotes), and …\nTakes a contents of a char literal (without quotes), and …\nTakes the contents of a mixed-utf8 literal (without …\nTakes a contents of a string literal (without quotes) and …\nTakes the contents of a unicode-only (non-mixed-utf8) …")