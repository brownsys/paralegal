searchState.loadedDescShard("miri", 0, "Isolated op is rejected with an abort of the machine.\nIndicates which kind of access is being performed.\nExtra per-allocation data\nExecute op requiring communication with the host, i.e. …\nJumping to the next block has already been taken care of.\nValid atomic fence orderings, subset of atomic::Ordering.\nValid atomic read orderings, subset of atomic::Ordering.\nValid atomic read-write orderings, alias of …\nValid atomic write orderings, subset of atomic::Ordering.\nKeeps track of what the thread is blocked on.\nTracking pointer provenance\nWhich borrow tracking method to use\n<code>malloc</code> memory.\nMemory allocated by <code>caller_location</code> intrinsic. Error if …\nHolds all of the relevant data for when unwinding hits a …\nA monotone clock used for <code>Instant</code> simulation.\nFor pointers with concrete provenance. we exactly know …\nBlocked on a condition variable.\n0 is used to indicate that the id was not yet assigned and,\n(new_tag, new_perm, (alloc_id, base_offset, orig_tag))\nFully recursively validate references.\nWe support <code>expose_provenance</code>/<code>with_exposed_provenance</code> via …\nGrants no access, but separates two groups of …\nType of dynamic symbols (for <code>dlsym</code> et al)\nWhat needs to be done after emulating an item (a shim or …\nBlocked on epoll.\nBlocked on eventfd.\nMemory for extern statics. This memory may leak.\nExtra data stored with each stack frame\nPrints a backtrace with all possible information.\nBlocked on a Futex variable.\nGlobals copied from <code>tcx</code>. This memory may leak.\nBlocked on an InitOnce.\n0 is used to indicate that the id was not yet assigned and,\nThe raw bytes of a simple value.\nCheck alignment on the actual physical integer address.\nA representation of an IO error: either a libc error name, …\nAn item in the per-location borrow stack.\nThe thread tried to join the specified thread and is …\nThe maximum number of CPUs supported by miri.\nInsert rustc arguments at the beginning of the argument …\nAdditional memory kinds a machine wishes to distinguish …\nMemory for args, errno, and other parts of the …\n<code>miri_alloc</code> memory.\nAllocation bytes that explicitly handle the layout of the …\nConfiguration needed to spawn a Miri instance.\nA rustc InterpCx for Miri.\nA little trait that’s useful to be inherited by …\nThe machine itself.\nExtra memory kinds\nMemory mapped directly by the program\nBlocked on a mutex.\nThe caller is expected to jump to the return block.\nThe caller is expected to jump to the unwind block.\nDon’t retag any fields.\nDo not perform any kind of validation.\nIf not Abort, miri returns an error for an isolated op. …\nMiri specific diagnostics\nDo not check alignment.\nThe item is not supported.\nPrints only the frame that the error occurs in.\nOnly retag fields of types with Scalar and ScalarPair …\nIndicates which permission is granted (by this item to …\nLike <code>Default</code>, but without the warning.\nThis <code>Item</code> was popped from the borrow stack. The string …\nPrecomputed layouts of primitive types\nPointer provenance.\nThe “extra” information a pointer has over a regular …\nA pointer.\nReject an op requiring communication with the host. By …\nPolicy on whether to recurse into fields to retag\nMemory allocated by the runtime (e.g. env vars). Separate …\n<code>__rust_alloc</code> memory.\nBlocked on a reader-writer lock.\n0 is used to indicate that the id was not yet assigned and,\nValidate the interior of the value, but not things behind …\nGrants shared read-only access.\nGrants shared mutable access.\nPrints a terser backtrace which ideally only contains …\nWaiting for time to pass.\nExtra per-location state.\nStack memory. Error if deallocated except during a stack …\nStacked Borrows, as implemented in …\nExtra per-allocation state.\nWe error on <code>with_exposed_provenance</code>, ensuring no precision …\nCheck alignment “symbolically”, i.e., using only the …\nThe state of all synchronization objects.\nDetails of premature program termination.\nA thread identifier.\nA set of threads.\nWhether the timeout is relative or absolute.\nThe clock to use for the timeout you are asking for.\nMemory for thread-local statics. This memory may leak.\nTree structure with both parents and children since we …\nTree borrows, as implemented in borrow_tracker/tree_borrows\nTrait for callbacks that are executed when a thread gets …\nGrants unique mutable access.\nPrint a warning about rejected isolated op, with backtrace.\nPrint a warning about rejected isolated op, without …\nPointers with wildcard provenance are created on …\nWindows <code>HeapAlloc</code> memory.\nWindows “local” memory (to be freed with <code>LocalFree</code>)\nRetag all fields.\nIdentifier of the currently active thread.\nProbability for address reuse across threads.\nProbability for address reuse.\nThis module is responsible for managing the absolute …\nPtr-int-cast module global data.\nThe spans we will use to report where an allocation was …\nProgram arguments (<code>Option</code> because we can only initialize …\nCommand-line arguments passed to the interpreted program.\nA backtrace to where this allocation was allocated. As …\nEquivalent setting as RUST_BACKTRACE on encountering an …\nWhich style to use for printing backtraces.\nExtra data for the Borrow Tracker.\nGlobal data for borrow tracking.\nDetermines if Stacked Borrows or Tree Borrows is enabled.\nGlobal state of the borrow tracker, if enabled.\nUsed <em>mostly</em> as a stack; never empty. Invariants:\nA small LRU cache of searches of the borrow stack.\nThe <code>catch_fn</code> callback to call in case of a panic.\nIf this is Some(), then this is a special “catch unwind…\nControls whether alignment of memory accesses is being …\nControls alignment checking.\nThis machine’s monotone clock.\nFailure rate of compare_exchange_weak, between 0.0 and 1.0\nRate of spurious failures for compare_exchange_weak atomic …\nWhether to collect a backtrace when each allocation is …\nWhether to collect a backtrace when each allocation is …\nMaps MIR consts to their evaluated result. We combine the …\nReturns a freshly created <code>InterpCx</code>. Public because this is …\nThe <code>data</code> argument for that callback.\nData race detector per-frame data.\nData race detector global data.\nData race detection via the use of a vector-clock. This is …\nDetermine if data race detection should be enabled\nThe return place from the original call to <code>try</code>.\nThe table of directory descriptors.\nThe host environment snapshot to use as basis for what is …\nEnvironment variables.\nThe list of all EpollEventInterest.\nMain evaluator loop and setting up the initial stack frame.\nEvaluates the entry function specified by <code>entry_id</code>. …\nCache of <code>Instance</code> exported under the given <code>Symbol</code> name. …\nThe set of tags that have been exposed inside this …\nMapping extern static names to their pointer.\nThe table of file descriptors.\nEnvironment variables that should always be forwarded from …\nRun a garbage collector for BorTags every N basic blocks.\nRun a garbage collector for BorTags every N basic blocks.\nStores past operations on this allocation\nDetermines if memory leaks should be ignored.\nIndicates whether a <code>Frame</code> is part of a workspace-local …\nWhat should Miri do when an op requires communicating with …\nAction for an op requiring communication with the host.\npthreads-style thread-local storage.\nStored layout information about the allocation.\nPrecomputed <code>TyLayout</code>s for primitive data types that are …\nCrates which are considered local for the purposes of …\nGlobal machine state as well as implementation of the …\nStores the <code>Machine</code> instance.\nOn macOS, each thread holds a list of destructor functions …\nReturn place of the main function.\nIf <code>Some</code>, enable the <code>measureme</code> profiler, writing results to …\nThe virtual memory system.\nThis is a “monotonic <code>FxHashMap</code>”: A <code>FxHashMap</code> that, …\nCorresponds to -Zmiri-mute-stdout-stderr and doesn’t …\nWhether to ignore any output by the program. This is …\nHandle of the optional shared object file for native …\nThe location of a shared object file to load when calling …\nThe Key to use for the next thread-local allocation.\nAll nodes of this tree.\nThe number of CPUs to be reported by miri.\nThe number of CPUs to be reported by miri.\nDetermines Miri’s page size and associated values\nRequires Miri to emulate pages of a certain size\nThe probability of the active thread being preempted at …\nThe probability of the active thread being preempted at …\nThe <code>measureme</code> profiler used to record timing information …\nWhich provenance to use for int2ptr casts\nPointer to the allocation contents. Invariant:\nImplements a map from integer indices to data. Rather than …\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nEmit a custom diagnostic without going through the …\nIf <code>Some</code>, we will report the current stack every N basic …\nReport the current instruction being executed every N …\nThe return block from the original call to <code>try</code>.\nWhether Stacked Borrows and Tree Borrows retagging should …\nThe random number generator used for resolving …\nThe index of the root node.\nMaps a tag and a location to a perm, with possible lazy …\nWe have a cache for the mapping from <code>mir::Const</code> to …\nThe seed to use when non-determinism or randomness are …\nAdditional environment variables that should be set in the …\nThe number of blocks that passed since the last BorTag GC …\nAllocations that are considered roots of static memory …\nUsed with <code>profiler</code> to cache the <code>StringId</code>s for event names …\nFor each allocation, an offset inside that allocation that …\nThe state of the primitive synchronization objects.\nSynchronization primitives like to attach extra data to …\nMapping from tags to keys. The key obtained can then be …\nThe results of the type checker, from rustc. The span in …\nStores which thread is eligible to run on which CPUs. This …\nA mapping from a thread-local static to the thread …\nThe set of threads.\nThreads used in the program.\nWill be invoked when the timeout ellapsed without the …\nIf <code>measureme</code> profiling is enabled, holds timing information\nTLS state.\nFor the tracked alloc ids, also report read/write accesses.\nFor the tracked alloc ids, also report read/write accesses.\nTrack when an outdated (weak memory) load happens.\nThe allocation IDs to report when they are being allocated …\nThe allocation ids to report about.\nThe stacked borrows pointer ids to report about\nWill be invoked when the thread was unblocked the “…\nA cache of “data range” computations for unions (i.e., …\nWhether <code>core::ptr::Unique</code> receives special treatment. If …\nOn a read, we need to disable all <code>Unique</code> above the …\nIf this is <code>Some(id)</code>, then the actual current stack is …\nWhether to enforce the validity invariant.\nDetermine if validity checking is enabled.\nWhether weak memory emulation is enabled\nWeak memory emulation via the use of store buffers. This …\nDetermine if weak memory emulation should be enabled. …\nA flag that indicates that we should change the active …\nBorrow Tracker tag.\nWe support <code>expose_provenance</code>/<code>with_exposed_provenance</code> via …\nLike <code>Default</code>, but without the warning.\nWe error on <code>with_exposed_provenance</code>, ensuring no precision …\nConvert a relative (tcx) pointer to a Miri pointer.\nShifts <code>addr</code> to make it aligned with <code>align</code> by rounding <code>addr</code> …\nThe base address for each allocation.  We cannot put that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWhether an allocation has been exposed or not. This cannot …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis is used as a map between the address of each …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is used as a memory address when a new pointer is …\nTemporarily store prepared memory space for global …\nThe provenance to use for int2ptr casts\nWhen a pointer is used for a memory access, this computes …\nA pool of addresses we can reuse for future allocations.\nManages a pool of addresses that can be reused.\nThe pool strikes a balance between exploring more possible …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe i-th element in <code>pool</code> stores allocations of alignment …\nReturns the address to use and optionally a clock we have …\nAllocation bytes that explicitly handle the layout of the …\nThis method factors out how a <code>MiriAllocBytes</code> object is …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStored layout information about the allocation.\nPointer to the allocation contents. Invariant:\nExtra per-allocation data for borrow tracking\nTracking pointer provenance\nWhich borrow tracking method to use\nPer-call-stack-frame data for borrow tracking\nWe need interior mutable access to the global state.\nExtra global state, available to the memory access hooks.\nDon’t retag any fields.\nOnly retag fields of types with Scalar and ScalarPair …\nThe flavor of the protector.\nPolicy on whether to recurse into fields to retag\nStacked Borrows, as implemented in …\nData corresponding to Stacked Borrows\nProtected against any kind of invalidation.\nTree borrows, as implemented in borrow_tracker/tree_borrows\nData corresponding to Tree Borrows\nProtected against aliasing violations from other pointers.\nRetag all fields.\nBorrow tracker method currently in use.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe default to be used when borrow tracking is disabled\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates a new pointer tag. Remember to also check …\nNext unused pointer ID (tag).\nThe minimum representable tag\nIf this frame is protecting any tags, they are listed …\nAll currently protected tags. We add tags to this when …\nTree Borrows needs to be told when a tag stops being …\nWhether to recurse into datatypes when searching for …\nTable storing the “root” tag for each allocation. The …\nImplements “Stacked Borrows”.  See …\nThe pointer ids to trace\nWhether <code>core::ptr::Unique</code> gets special (<code>Box</code>-like) handling.\nDetermines whether an item was invalidated by a …\nIndicates which permissions to grant to the retagged …\nExtra per-allocation state.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe set of tags that have been exposed inside this …\nThe set of tags that have been exposed inside this …\nCall <code>f</code> on every stack in the range.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA key function: determine the permissions to grant at a …\nStores past operations on this allocation\nStores past operations on this allocation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new stack with an initial tag. For diagnostic …\nMark the given tag as exposed. It was found on a pointer …\nProtect a place so that it cannot be used any more for the …\nReturns the provenance that should be used henceforth.\nRetags an individual pointer, returning the retagged …\nReport a descriptive error when <code>access</code> is not permitted …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nError reporting\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReport a descriptive error when <code>new</code> could not be granted …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGrants no access, but separates two groups of …\nAn item in the per-location borrow stack.\nIndicates which permission is granted (by this item to …\nGrants shared read-only access.\nGrants shared mutable access.\nGrants unique mutable access.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis defines for a given permission, whether it permits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe permission this item grants.\nWhether or not there is a protector for this tag\nSet the Permission stored in this Item\nThe pointers the permission is granted to.\nExactly what cache size we should use is a difficult …\nExtra per-location state.\nA very small cache of searches of a borrow stack, mapping …\nTest if a memory <code>access</code> using pointer tagged <code>tag</code> is …\nWhen a tag is used, we call this function to add or …\nUsed <em>mostly</em> as a stack; never empty. Invariants:\nA small LRU cache of searches of the borrow stack.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nDeallocate a location: Like a write access, but also there …\nFind all <code>Unique</code> elements in this borrow stack above …\nFind the first write-incompatible item above the given one …\nFind the item granting the given kind of access to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDerive a new pointer from one with the given tag.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe given item was invalidated – check its protectors …\nConstruct a new <code>Stack</code> using the passed <code>Item</code> as the root …\nProduces an iterator which iterates over <code>range</code> in reverse, …\nOn a read, we need to disable all <code>Unique</code> above the …\nIf this is <code>Some(id)</code>, then the actual current stack is …\nPolicy for a new borrow.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nDetermine NewPermission of the reference from the type of …\nCompute permission for <code>Box</code>-like type (<code>Box</code> always, and also …\nWhich permission should the pointer start with.\nTakes a place for a <code>Unique</code> and turns it into a place with …\nCalls <code>U::from(self)</code>.\nAll nodes of this tree.\nDisplay the tree.\nWhether this pointer is part of the arguments of a …\nThe index of the root node.\nMaps a tag and a location to a perm, with possible lazy …\nMapping from tags to keys. The key obtained can then be …\nMark the given tag as exposed. It was found on a pointer …\nGive a name to the pointer, usually the name it has in the …\nProtect a place so that it cannot be used any more for the …\nReturns the provenance that should be used henceforth.\nRetag all pointers that are stored in this place.\nRetag a pointer. References are passed to <code>from_ref_ty</code> and …\nRetags an individual pointer, returning the retagged …\nIn this file we handle the “Tree” part of Tree …\nThis module implements the <code>UniMap</code>, which is a way to get …\nOptionally ignore the actual size to do a zero-size …\nCause of an access: either a real access or one inserted …\nThis access is not allowed because some parent tag has …\nAll parameters to determine how the tree is formatted.\nHow to show whether a location has been accessed\nFormatting of the tree structure.\nFormatting of the permissions on each range.\nPretty-printing details\nTrack the indentation of the tree.\nExtracted information from the tree, in a form that is …\nComplete data for an event:\nList of all events that affected a tag. NOTE: not all of …\nHistory formatted for use by <code>src/diagnostics.rs</code>.\nSome information that is irrelevant for the algorithm but …\nCannot deallocate because some tag in the allocation is …\nA protector was triggered due to an invalid transition …\nFailures that can occur during the execution of Tree …\nKind of the access that triggered this event.\nUser-visible range of the access. <code>None</code> means that this is …\nWhich tag the access that caused this error was made …\nAdd a name to the tag. If a same tag is associated to …\nThe allocation in which the error is happening.\nCharacter repeated to make the lower border.\nProduce a UB error.\nRepeat a character a number of times.\nText that ends the permission block.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe tag on which the error was triggered. On protector …\nPop the last level of indentation.\nWhat failure occurred.\nThe offset (into the allocation) at which the conflict …\nReconstruct the history relevant to <code>error_offset</code> by …\nKeep only the tag and creation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNotable events in the history of this tag, used for …\nIncrement the indentation by one. Note: need to know if …\nIndentation for the last child.\nIndentation when there is a next child.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRelative position of the tag to the one used for the …\nConnector for a node that does not have a child. Should …\nConnector for a node that itself has a child.\nConnector for the last child. Should have the same width …\nConnector for a child other than the last.\nUsed when there is no <code>State</code>. Should have the same width as …\nName(s) that were associated with this tag …\nInformation for a new node. By default it has no name and …\nUsed when <code>State.initialized = false</code>. Should have the same …\nText that starts the permission block.\nPrint the permission with the format <code> Res</code>/<code> Re*</code>/<code> Act</code>/<code> Frz</code>/…\nPrint extra text if the tag has a protector.\nPrint the tag with the format <code>&lt;XYZ&gt;</code> if the tag is unnamed, …\nRecord an additional event to the history.\nText to separate the <code>start</code> and <code>end</code> values of a range.\nText that separates permissions on different ranges.\nLine of code that triggered this event.\nThe tag in question.\nCharacter repeated to make the upper border.\nTransformation of permissions that occurred because of …\nThe transition recorded by this event only occurred on a …\nText to show when a permission is not initialized. Should …\nWarning about some tags (unnamed) being hidden.\nPrint the current indentation.\nUsed when <code>State.initialized = true</code>.\nTo speed up tree traversals, we want to skip traversing …\nReturns true if a node where the strongest idempotent …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nDuring retags, the SIFA needs to be weakened to account …\nReturns the argument unchanged.\nUsually, tree traversals have an <code>AccessKind</code> and an …\nConstructs a foreign access from an <code>AccessKind</code>\nCalls <code>U::from(self)</code>.\nReturns true if this access is foreign, i.e. not local.\nReturns true if this access is local.\nUpdates <code>self</code> to account for a foreign access.\nrepresents: a unique pointer; allows: child reads, child …\nrepresents: a dead pointer; allows: all foreign accesses; …\nrepresents: a shared pointer; allows: all read accesses; …\nTransition from one permission to the next.\nPublic interface to the state machine that controls …\nThe activation states of a pointer.\nrepresents: a local mutable reference that has not yet …\nAlternative version of <code>ReservedFrz</code> made for types with …\nExtract result of a transition (checks that the starting …\nDuring a provenance GC, we want to compact the tree. For …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReject <code>ReservedIM</code> that cannot exist in the presence of a …\nReject <code>ReservedIM</code> that cannot exist in the presence of a …\nEndpoint of a transition. Meant only for diagnostics, use …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if <code>self</code> is the post-child-write state of a pointer …\nCheck if <code>self</code> is the terminal state of a pointer (is …\nCheck if <code>self</code> can be the initial state of a pointer.\nCheck if <code>self</code> can be the initial state of a pointer.\nAll transitions created through normal means (using …\nDetermines whether <code>self</code> is a relevant transition for the …\nDefault initial permission of the root of a new tree at …\nDefault initial permission of  the root of a new tree at …\nDefault initial permission of a reborrowed shared …\nWrapper around <code>new_reserved_frz</code> and <code>new_reserved_im</code> that …\nDefault initial permission of a reborrowed mutable …\nDefault initial permission of an unprotected interior …\nPermissionPriv is ordered by the reflexive transitive …\nApply the transition to the inner PermissionPriv.\nDetermines if this transition would disable the permission.\nAbbreviated name of the permission (uniformly 3 letters …\nExtract starting point of a transition\nSee <code>foreign_access_skipping.rs</code>. Computes the SIFA of a …\nReturns the strongest foreign action this node survives …\nReadable explanation of the consequences of an event. Fits …\nThis module controls how each permission individually …\nA child node was read-accessed: UB on Disabled, noop on …\nA child node was write-accessed: <code>Reserved</code> must become …\nA non-child node was read-accessed: keep <code>Reserved</code> but mark …\nA non-child node was write-accessed: this makes everything …\nDispatch handler depending on the kind of access and its …\nRelative position of the access\nThe accessed pointer is a (transitive) parent of the …\nWhether to continue exploring the children recursively or …\nThe accessed pointer is neither of the above.\nData given to the error handler\nData for a single <em>location</em>.\nA node in the borrow tree. Each node is uniquely …\nData given to the transition function\nThe accessed pointer is a (transitive) child of the …\nThe accessed pointer is the current one\nTree structure with both parents and children since we …\nInternal contents of <code>Tree</code> with the minimum of mutable …\nStack of nodes left to explore in a tree traversal. See …\nInformation about the tag that was accessed just before the\nCheck that an access on the entire range is permitted, and …\nCheck that this pointer has permission to deallocate this …\nChecks whether a node can be replaced by its only child. …\nIf the pointer was reborrowed, it has children.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nTag that triggered the error (not the tag that was …\nDeallocation requires\nSome extra information useful only for debugging purposes\nThe default initial (strongest) idempotent foreign access. …\nEither <code>Reserved</code>,  <code>Frozen</code>, or <code>Disabled</code>, it is the …\nHandler to add the required context to diagnostics.\nKind of error that occurred\nFunction describing whether to continue at a tag. This is …\nFunction to apply to each tag.\nGiven the AccessRelatedness for the parent node, compute …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDebug helper: assign name to tag.\nSee <code>foreign_access_skipping.rs</code>. Stores an idempotent …\nIdentifier of the original access.\nA location is initialized when it is child-accessed for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDebug helper: determines if the tree contains a tag.\nCheck that access is either Ancestor or Distant, i.e. not …\nCheck if the state can exist as the initial permission of …\nCheck if the location has been initialized, i.e. if it has …\nChecks if a node is useless and should be GC’ed. A node …\nCreate a new tree, with only a root pointer.\nCreate a new allocation, i.e. a new tree\nInsert a new tag in the tree\nConstructs a new initial state. It has not yet been …\nConstructs a new initial state. It has neither been …\nNode on which the transition is currently being applied\nAll nodes of this tree.\nClimb the tree to get the tag of a distant ancestor. …\nAll tags except the root have a parent tag.\nApply the effect of an access to one location, including\nMap the per-node and per-location …\nMutable access to its permissions\nThis pointer’s current permission / future initial …\nDisplay the contents of the tree.\nRecords a new access, so that future access can …\nRelative position of the access\nA tag just lost its protector.\nTraverses the entire tree looking for useless tags. …\nProperly removes a node. The node to be removed should not …\nThe index of the root node.\nMaps a tag and a location to a perm, with possible lazy …\nTree traversal optimizations. See …\nMutable state of the visit: the tags left to handle. Every …\nThe tag of this node.\nMapping from tags to keys. The key obtained can then be …\nLike <code>traverse_this_parents_children_other</code>, but skips the …\nApplies <code>f_propagate</code> to every vertex of the tree in a …\nRestores the SIFA “children are stronger” invariant …\nAn access to a single value of the map.\nIntermediate key between a UniKeyMap and a UniValMap.\nFrom K to UniIndex\nFrom UniIndex to V\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWhether this index has an associated value.\nWhether this key has an associated index or not.\nThe mapping data. Thanks to Vec we get both fast accesses, …\nIndexes that can be reused: memory gain when the map gets …\nGet a wrapper around a mutable access to the value …\n2023-05: We found that using <code>equivalent</code> rather than …\nEquality up to trailing <code>None</code>s of two maps, i.e. do they …\nReserve enough space to insert the value at the right …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf it exists, the index this key maps to.\nGet the value at this index, if it exists.\nGet the value at this index mutably, if it exists.\nEither get a previously existing entry, or create a new …\nExact equality of two maps. Less accurate but faster than …\nAssign this key to a new index. Panics if the key is …\nAssign a value to the index. Permanently overwrites any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHow many keys/index pairs are currently active.\nUnderlying map that does all the hard work. Key invariant: …\nInsert in the map and get the value.\nReturn whatever index this key was using to the deassigned …\nDelete any value associated with this index. Returns None …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA monotone clock used for <code>Instant</code> simulation.\nWhen using a virtual clock, this defines how many …\nWill try to add <code>duration</code>, but if that overflows it may add …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturn the <code>epoch</code> instant (time = 0), to convert between …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new clock based on the availability of …\nSleep for the desired duration.\nLet the time pass for a small interval.\nThe “epoch” for this machine’s monotone clock: the …\nThe “current virtual time”.\nImplementation of a data-race detector using Lamport …\nImplements a map from allocation ranges to data. This is …\nImplements threads.\nImplementation of C++11-consistent weak memory emulation …\nA thread’s CPU affinity mask determines the set of CPUs …\nThe maximum number of CPUs supported by miri.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAllocate memory.\nValid atomic fence orderings, subset of atomic::Ordering.\nExternally stored memory cell clocks explicitly to reduce …\nValid atomic read orderings, subset of atomic::Ordering.\nValid atomic read-write orderings, alias of …\nValid atomic write orderings, subset of atomic::Ordering.\nError returned by finding a data race should be elaborated …\nDeallocate memory. Note that when memory is deallocated …\nVector clock state for a stack frame (tracking the local …\nGlobal data-race detection state, contains the currently …\nStripped-down version of <code>MemoryCellClocks</code> for the clocks …\nPer-byte vector clock metadata for data-race detection.\nType of a non-atomic read operation.\nType of a non-atomic write operation: allocating memory, …\nStandard unsynchronized write.\nThe current set of vector clocks describing the state of a …\nExtra metadata associated with a thread.\nVector clock metadata for a logical memory allocation.\nStandard unsynchronized write.\nAcquire the given clock into the current thread, …\nAcquire the given clock into the current thread, …\nReturn the current thread, should be the same as the …\nLoad the current vector clock in use and the current set …\nLoad the current vector clock in use and the current set …\nAssigning each byte a MemoryCellClocks.\nAssigning each byte a MemoryCellClocks.\nAfter all threads are done running, this allows data races …\nSame as <code>allow_data_races_ref</code>, this temporarily disables …\nTemporarily allow data-races to occur. This should only be …\nApply the effects of an acquire fence to this set of …\nApply the effects of a release fence to this set of thread …\nLoad the internal atomic memory cells if they exist.\nLoad or create the internal atomic memory metadata if it …\nChecks that an atomic access is legal at the given place.\nPerform an atomic compare and exchange at a given memory …\nPerform an atomic exchange with a memory place and a new …\nUpdate the data-race detector for an atomic fence on the …\nPerform an conditional atomic exchange with a memory place …\nLoad the internal atomic memory cells if they exist.\nAtomic access, acquire, release sequence tracking clocks. …\nDetect data-races with an atomic read, caused by a …\nPerform an atomic RMW operation on a memory location.\nDetect data-races with an atomic write, either with a …\nThe increasing clock representing timestamps that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe set of timestamps that will happen-before this thread …\nThe last timestamp of happens-before relations that have …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncrement the happens-before clock at a known index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJoin the happens-before clock with that of another thread, …\nWe make SC fences act like RMWs on a global location. To …\nThe timestamp of last SC write performed by each thread. …\nUpdate memory cell data-race tracking for atomic load …\nUpdate memory cell data-race tracking for atomic load …\nAttempt to perform a synchronized operation, this will …\nSet to true once the first additional thread has launched, …\nCreate a new set of clocks representing memory allocated …\nCreate a new global state, setup with just thread-id=0 …\nCreate a new data-race detector for newly allocated memory.\nA flag to mark we are currently performing a data race …\nInternal utility to identify a thread stored internally …\nDetect data-races for an unsynchronized read operation. It …\nThe vector-clock of all non-atomic reads that happened …\nDetect races for non-atomic read operations at the current …\nPerform an atomic read operation at the memory location.\nTimestamps of the last SC fence performed by each thread, …\nThe clock-vector of the timestamp of the last atomic read …\nCalls the callback with the “release” clock of the …\nCalls the given closure with the “release” clock of …\nReport a data-race found in the program. This finds the …\nPotential vector indices that could be re-used on thread …\nUpdate the memory cell data-race tracking for atomic store …\nUpdate the memory cell data-race tracking for atomic store …\nThe size of accesses to this atomic location. We use this …\nUpdate the memory cell data-race tracking for atomic store …\nUpdate the memory cell data-race tracking for atomic store …\nSynchronization vector for acquire-release semantics …\nThread termination vector clock, this is set on thread …\nThe mapping of a given thread to associated thread …\nHook on a thread join to update the implicit …\nLoad the vector index used by the given thread as well as …\nLoad the vector index used by the given thread as well as …\nOn thread termination, the vector-clock may re-used in the …\nTrack when an outdated (weak memory) load happens.\nUpdate the data-race detector for an atomic read occurring …\nGeneric atomic operation implementation\nUpdate the data-race detector for an atomic …\nUpdate the data-race detector for an atomic write …\nMapping of a vector index to a known set of thread clocks, …\nThe current vector index in use by the thread currently, …\nMapping of a given vector index to the current thread that …\nDetect data-races for an unsynchronized write operation. …\nThe vector-clock timestamp and the thread that did the …\nDetect races for non-atomic write operations at the …\nPerform an atomic write operation at the memory location.\nTimestamps of the last SC write performed by each thread, …\nThe type of operation that the write index represents, …\nThe clock-vector of the timestamp of the last atomic write …\nThe one time initialization state.\n0 is used to indicate that the id was not yet assigned and,\nThe current status of a one time initialization.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBegin initializing this InitOnce. Must only be called …\nPut the thread into the queue waiting for the …\nSynchronize with the previous completion of an InitOnce. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe access does not touch any existing allocation\nThe access overlaps with one or more existing allocations\nThe access perfectly overlaps (same offset and range) with …\nIndex of an allocation within the map\nDetermines whether a given access on <code>range</code> overlaps with …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe data stored for this element.\nFinds the position of the allocation containing the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts an object and its occupied range at given position\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe range covered by this element; never empty.\nThe conditional variable state.\n0 is used to indicate that the id was not yet assigned and,\nThe futex state.\nA thread waiting on a futex.\nWe designate an <code>init`` field in all primitives. If </code>init` …\nThe mutex state.\nThe read-write lock state.\n0 is used to indicate that the id was not yet assigned and,\nThe state of all synchronization objects.\nThe bitset used by FUTEX_*_BITSET, or u32::MAX for other …\nMutex clock. This tracks the moment of the last unlock.\nTracks the happens-before relationship between a cond-var …\nTracks the happens-before relationship between a …\nData race clock for readers. This is temporary storage for …\nData race clock for writers. Tracks the happens-before …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIs the conditional variable awaited?\nWake up some thread (if there is any) sleeping on the …\nRelease the mutex and let the current thread wait on the …\nWe cannot use the <code>newtype_index!</code> macro because we have to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWait for the futex to be signaled, or a timeout. On a …\nWake up the first thread in the queue that matches any of …\nGet the synchronization primitive associated with the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper for lazily initialized <code>alloc_extra.sync</code> data: …\nHelper for lazily initialized <code>alloc_extra.sync</code> data: this …\nHow many times the mutex was locked by the owner.\nPut the thread into the queue waiting for the mutex.\nGet the id of the thread that currently owns this lock.\nCheck if locked.\nLock by setting the mutex owner and increasing the lock …\nTry unlocking by decreasing the lock count and returning …\nThe thread that currently owns the lock.\nThe queue of threads waiting for this mutex.\nThe queue of reader threads waiting for this lock.\nThe readers that currently own the lock and how many times …\nPut the reader in the queue waiting for the lock and block …\nPut the writer in the queue waiting for the lock. Once the …\nCheck if locked.\nCheck if write locked.\nRead-lock the lock by adding the <code>reader</code> the list of …\nTry read-unlock the lock for the current threads and …\nLock by setting the writer that owns the lock.\nTry to unlock an rwlock held by the current thread. Return …\nThe thread that is waiting on this futex.\nThe writer thread that currently owns the lock.\nThe queue of writer threads waiting for this lock.\nKeeps track of what the thread is blocked on.\nThe thread is blocked on something.\nBlocked on a condition variable.\nDeallocate backing memory of thread-local statics as usual\nA thread is detached if its join handle was destroyed and …\nThe thread is enabled and can be executed.\nBlocked on epoll.\nBlocked on eventfd.\nExecute step on the active thread.\nExecute a timeout callback.\nBlocked on a Futex variable.\nBlocked on an InitOnce.\nThe thread tried to join the specified thread and is …\nThe thread can be joined.\nThe thread was already joined by some thread and cannot be …\nSkip deallocating backing memory of thread-local statics …\nBlocked on a mutex.\nBlocked on a reader-writer lock.\nWait for a bit, until there is a timeout to be called.\nWaiting for time to pass.\nThe thread has terminated its execution. We do not delete …\nA thread.\nA thread identifier.\nThe join status of a thread.\nA set of threads.\nAn error signaling that the requested thread doesn’t …\nThe state of a thread.\nThe moment in time when a blocked thread should be woken …\nWhether the timeout is relative or absolute.\nThe clock to use for the timeout you are asking for.\nWhat to do with TLS allocations from terminated threads\nTrait for callbacks that are executed when a thread gets …\nGet the id of the currently active thread.\nIdentifier of the currently active thread.\nGet a mutable borrow of the currently active thread.\nGet a shared borrow of the currently active thread.\nBorrow the stack of the active thread.\nMutably borrow the stack of the active thread.\nWill try to add <code>duration</code>, but if that overflows it may add …\nBlock the current thread, with an optional timeout. The …\nPut the thread into the blocked state.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturn the top user-relevant frame, if there is one. Note …\nCreate a new thread and returns its id.\nMark the thread as detached, which means that no other …\nEnable the thread for execution. The thread must be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the total of threads that are currently live, i.e., …\nGet a thread-specific allocation id for the given …\nCheck if we have an allocation for the given thread local …\nGet the name of the given thread.\nGet the total number of threads that were ever spawn by …\nHow long do we have to wait from now until the specified …\nHas the given thread terminated?\nHave all threads terminated?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe join status.\nMark that the active thread tries to join the thread with …\nMark that the active thread tries to exclusively join the …\nLast OS error location in memory. It is a 32-bit integer.\nCreate a new thread id from a <code>u32</code> without checking if this …\nGet the wait time for the next timeout, or <code>None</code> if no …\nThe function to call when the stack ran empty, to figure …\nStack of active panic payloads for the current thread. …\nRe-compute the top user-relevant frame from scratch.\nRun the core interpreter loop. Returns only when an …\nExecute a timeout callback on the callback’s thread.\nDecide which action to take next and on which thread.\nSet an active thread and return the id of the thread that …\nSet the pointer for the allocation of the given thread …\nSet the name of the current thread. The buffer must not …\nSet the name of the given thread.\nSet the top user-relevant frame to the given value. Must …\nThe virtual call stack.\nStart a regular (non-main) thread.\nHandles thread termination of the active thread: wakes up …\nGet the name of the current thread for display purposes; …\nA mapping from a thread-local static to the thread …\nGet the name of the current thread if it was set.\nName of the thread.\nThreads used in the program.\nWill be invoked when the timeout ellapsed without the …\nReturns the topmost frame that is considered …\nThe index of the topmost user-relevant frame in <code>stack</code>. …\nWill be invoked when the thread was unblocked the “…\nPut the blocked thread into the enabled state. …\nChange the active thread to some enabled thread.\nA flag that indicates that we should change the active …\nThe size of the vector-clock to store inline clock vectors …\nA vector clock for detecting data-races, this is …\nThe time-stamps recorded in the data-race detector consist …\nA vector clock index, this is associated with a thread id …\nLoad the internal timestamp slice in the vector clock\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable slice to the internal vector with minimum …\nIncrement the vector clock at a known index this will …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new vector-clock containing all zeros except for …\nSet the element at the current index of the vector. May …\nSet the vector to the all-zero vector\nThe lowest bit indicates read type, the rest is the time. <code>1</code>…\nWhether a load returned the latest value or not.\nAdd the given write to the store buffer. (Does not change …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nSelects a valid store element in the buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets a mutable store buffer associated with an atomic …\nGets a store buffer associated with an atomic object in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this store is SC.\nATOMIC LOAD IMPL in the paper Unlike the operational …\nMetadata about loads from this store element, behind a …\nWhen a non-atomic access happens on a location that has …\nCaller should never need to consult the store buffer for …\nReads from the last store in modification order, if any.\nWhether this store element has been read by an SC load\nStore buffer of each atomic object in this allocation\nStore buffer of each atomic object in this allocation\nATOMIC STORE IMPL in the paper (except we don’t need the …\nThe identifier of the vector index, corresponding to a …\nThe timestamp of the storing thread when it performed the …\nTimestamp of first loads from this store element by each …\nThe value of this store. <code>None</code> means uninitialized.\n(new_tag, new_perm, (alloc_id, base_offset, orig_tag))\nLevel of Miri specific diagnostics\nMiri specific diagnostics\nThis <code>Item</code> was popped from the borrow stack. The string …\nDetails of premature program termination.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWe had a panic in Miri itself, try to print something …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerate a note/help text without a span.\nGenerate a note/help text with a span.\nAttempts to prune a stacktrace to omit the Rust runtime, …\nEmit a custom diagnostic without going through the …\nReport an error or note (depending on the <code>error</code> argument) …\nIsolated op is rejected with an abort of the machine.\nExecute op requiring communication with the host, i.e. …\nFully recursively validate references.\nPrints a backtrace with all possible information.\nCheck alignment on the actual physical integer address.\nWhen the main thread would exit, we will yield to any …\nThe state of the main thread. Implementation detail of …\nConfiguration needed to spawn a Miri instance.\nDo not perform any kind of validation.\nIf not Abort, miri returns an error for an isolated op. …\nDo not check alignment.\nPrints only the frame that the error occurs in.\nReject an op requiring communication with the host. By …\nValidate the interior of the value, but not things behind …\nPrints a terser backtrace which ideally only contains …\nCheck alignment “symbolically”, i.e., using only the …\nPrint a warning about rejected isolated op, with backtrace.\nPrint a warning about rejected isolated op, without …\nProbability for address reuse across threads.\nProbability for address reuse.\nCommand-line arguments passed to the interpreted program.\nTurns an array of arguments into a Windows command line …\nWhich style to use for printing backtraces.\nDetermines if Stacked Borrows or Tree Borrows is enabled.\nControls alignment checking.\nRate of spurious failures for compare_exchange_weak atomic …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWhether to collect a backtrace when each allocation is …\nReturns a freshly created <code>InterpCx</code>. Public because this is …\nDetermine if data race detection should be enabled\nThe host environment snapshot to use as basis for what is …\nEvaluates the entry function specified by <code>entry_id</code>. …\nEnvironment variables that should always be forwarded from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRun a garbage collector for BorTags every N basic blocks.\nDetermines if memory leaks should be ignored.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAction for an op requiring communication with the host.\nIf <code>Some</code>, enable the <code>measureme</code> profiler, writing results to …\nWhether to ignore any output by the program. This is …\nThe location of a shared object file to load when calling …\nThe number of CPUs to be reported by miri.\nRequires Miri to emulate pages of a certain size\nThe probability of the active thread being preempted at …\nWhich provenance to use for int2ptr casts\nReport the current instruction being executed every N …\nWhether Stacked Borrows and Tree Borrows retagging should …\nThe seed to use when non-determinism or randomness are …\nAdditional environment variables that should be set in the …\nFor the tracked alloc ids, also report read/write accesses.\nTrack when an outdated (weak memory) load happens.\nThe allocation ids to report about.\nThe stacked borrows pointer ids to report about\nWhether <code>core::ptr::Unique</code> receives special treatment. If …\nDetermine if validity checking is enabled.\nDetermine if weak memory emulation should be enabled. …\nIndicates which kind of access is being performed.\nConvert a softfloat type to its corresponding hostfloat …\nConvert a hostfloat type to its corresponding softfloat …\nHelper function used inside the shims of foreign functions …\nHelper function used inside the shims of foreign functions …\nCall a function: Push the stack frame and pass the …\nCheck that the ABI is what we expect.\nCheck that the number of args is what we expect.\nCheck that the number of args is at least the minumim what …\nHelper function used inside the shims of foreign functions …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCalculates the MPlaceTy given the offset and layout of an …\nDereference a pointer operand to a place using <code>layout</code> …\nHelper function to get a <code>libc</code> constant as a <code>Scalar</code>.\nHelper function to get a <code>libc</code> constant as an <code>i32</code>.\nHelper function to get a <code>libc</code> constant as an <code>u32</code>.\nEvaluates the scalar at the specified path.\nHelper function to get a <code>windows</code> constant as a <code>Scalar</code>.\nHelper function to get a <code>windows</code> constant as a <code>u32</code>.\nHelper function to get a <code>windows</code> constant as a <code>u64</code>.\nChecks that target feature <code>target_feature</code> is enabled.\nConverts <code>src</code> from floating point to integer type <code>dest_ty</code> …\nReturns the argument unchanged.\nGenerate some random bytes, and write them to <code>dest</code>.\nRetrieve the list of local crates that should have been …\nReturns an integer type that is twice wide as <code>ty</code>\nChecks if the given crate/module exists.\nCalls <code>U::from(self)</code>.\nCall <code>f</code> for each exported symbol.\nHelper function to get <code>TyAndLayout</code> of an array that …\nHelper function to get the <code>TyAndLayout</code> of a <code>libc</code> type\nLookup an array of immediates stored as a linker section …\nMark a machine allocation that was just created as …\nGets the layout of a type at a path.\nProject to the given <em>named</em> field (which must be a struct …\nSearch if <code>base</code> (which must be a struct or union type) …\nTest if this pointer equals 0.\nRead bytes from a byte slice.\nRead a sequence of bytes until the first null terminator.\nHelper function to read a sequence of unsigned integers of …\nParse a <code>timespec</code> struct and return it as a …\nRead a sequence of wchar_t until the first null terminator.\nRead a sequence of u16 until the first null terminator.\nHelper function used inside the shims of foreign functions …\nGets an instance for a path.\nGets an instance for a path.\nGets an instance for a path; fails gracefully if the path …\nVisits the memory covered by <code>place</code>, sensitive to freezing: …\nCheck whether an operation that writes to a target buffer …\nHelper function to get the <code>TyAndLayout</code> of a <code>windows</code> type\nHelper function to write a sequence of bytes with an added …\nWrite an int of the appropriate size to <code>dest</code>. The target …\nWrite the first N fields of the given place.\nWrite the given fields of the given place.\nWrite a 0 of the appropriate size to <code>dest</code>.\nHelper function to write a sequence of u16 with an added …\nEmulates a Miri-supported intrinsic (not supported by the …\nThe <code>bool</code> indicates whether the result of the operation …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCalls the atomic intrinsic <code>intrinsic</code>; the <code>atomic_</code> prefix …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCalls the simd intrinsic <code>intrinsic</code>; the <code>simd_</code> prefix has …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEach anonymous global (constant, vtable, function pointer, …\nExtra per-allocation data\n<code>malloc</code> memory.\nMemory allocated by <code>caller_location</code> intrinsic. Error if …\nFor pointers with concrete provenance. we exactly know …\nMemory for extern statics. This memory may leak.\nExtra data stored with each stack frame\nGlobals copied from <code>tcx</code>. This memory may leak.\nAdditional memory kinds a machine wishes to distinguish …\nMemory for args, errno, and other parts of the …\n<code>miri_alloc</code> memory.\nA rustc InterpCx for Miri.\nA little trait that’s useful to be inherited by …\nThe machine itself.\nExtra memory kinds\nMemory mapped directly by the program\nPrecomputed layouts of primitive types\nPointer provenance.\nThe “extra” information a pointer has over a regular …\nMemory allocated by the runtime (e.g. env vars). Separate …\n<code>__rust_alloc</code> memory.\nLast real-time signal. <code>signal(7)</code> says it must be between …\nFirst real-time signal. <code>signal(7)</code> says this must be …\nStack memory. Error if deallocated except during a stack …\nMemory for thread-local statics. This memory may leak.\nPointers with wildcard provenance are created on …\nWindows <code>HeapAlloc</code> memory.\nWindows “local” memory (to be freed with <code>LocalFree</code>)\nCalled to adjust global allocations to the Provenance and …\nPtr-int-cast module global data.\nThe spans we will use to report where an allocation was …\nProgram arguments (<code>Option</code> because we can only initialize …\nA backtrace to where this allocation was allocated. As …\nEquivalent setting as RUST_BACKTRACE on encountering an …\nExtra data for the Borrow Tracker.\nGlobal data for borrow tracking.\nGlobal state of the borrow tracker, if enabled.\nReturns the span of the <em>caller</em> of the current operation, …\nIf this is Some(), then this is a special “catch unwind…\nControls whether alignment of memory accesses is being …\nThis machine’s monotone clock.\nFailure rate of compare_exchange_weak, between 0.0 and 1.0\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWhether to collect a backtrace when each allocation is …\nMaps MIR consts to their evaluated result. We combine the …\nGet the current span in the topmost function which is …\nData race detector per-frame data.\nData race detector global data.\nData race detection via the use of a vector-clock. This is …\nThe table of directory descriptors.\nEnvironment variables.\nThe list of all EpollEventInterest.\nCache of <code>Instance</code> exported under the given <code>Symbol</code> name. …\nCalled on <code>ptr as usize</code> casts. (Actually computing the …\nMapping extern static names to their pointer.\nThe table of file descriptors.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRun a garbage collector for BorTags every N basic blocks.\nCalled when the interpreter is going to shut down …\nSets up the “extern statics” for this machine.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether the stack frame that this <code>FrameInfo</code> refers …\nThis is the source of truth for the <code>is_user_relevant</code> flag …\nIndicates whether a <code>Frame</code> is part of a workspace-local …\nWhat should Miri do when an op requires communicating with …\nPrecomputed <code>TyLayout</code>s for primitive data types that are …\nCrates which are considered local for the purposes of …\nStores the <code>Machine</code> instance.\nReturn place of the main function.\nThe virtual memory system.\nCorresponds to -Zmiri-mute-stdout-stderr and doesn’t …\nHandle of the optional shared object file for native …\nZero-initialized pointer-sized extern statics are pretty …\nThe number of CPUs to be reported by miri.\nDetermines Miri’s page size and associated values\nThe probability of the active thread being preempted at …\nThe <code>measureme</code> profiler used to record timing information …\nCalled on <code>usize as ptr</code> casts.\nConvert a pointer with provenance into an …\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nIf <code>Some</code>, we will report the current stack every N basic …\nThe random number generator used for resolving …\nWe have a cache for the mapping from <code>mir::Const</code> to …\nWhether we have a useful allocation span for an allocation …\nThe number of blocks that passed since the last BorTag GC …\nAllocations that are considered roots of static memory …\nUsed with <code>profiler</code> to cache the <code>StringId</code>s for event names …\nFor each allocation, an offset inside that allocation that …\nThe state of the primitive synchronization objects.\nSynchronization primitives like to attach extra data to …\nThe results of the type checker, from rustc. The span in …\nStores which thread is eligible to run on which CPUs. This …\nThe set of threads.\nIf <code>measureme</code> profiling is enabled, holds timing information\nTLS state.\nFor the tracked alloc ids, also report read/write accesses.\nThe allocation IDs to report when they are being allocated …\nA cache of “data range” computations for unions (i.e., …\nWhether to enforce the validity invariant.\nWhether weak memory emulation is enabled\nWeak memory emulation via the use of store buffers. This …\nExtern statics that are initialized with function pointers …\nBorrow Tracker tag.\nDisturbes a floating-point result by a relative error on …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nRead-only lookup (avoid read-acquiring the RefCell).\nThe most interesting method: Providing a shared reference …\nCalls <code>U::from(self)</code>.\nThis function exists for priroda to be able to iterate …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe data stored for this element.\nFinds the index containing the given offset.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProvides read-only iteration over everything in the given …\nProvides iteration over all elements. The iterator also …\nProvides mutable iteration over everything in the given …\nProvides mutable iteration over all elements. The iterator …\nRemove all adjacent duplicates\nCreates a new <code>RangeMap</code> for the given size, and with the …\nThe range covered by this element; never empty.\nJumping to the next block has already been taken care of.\nWhat needs to be done after emulating an item (a shim or …\nThe caller is expected to jump to the return block.\nThe caller is expected to jump to the unwind block.\nThe item is not supported.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nProvides the <code>extern static</code> that this platform expects.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nImplements calling functions from a native library.\nPanic runtime for Miri.\nImplement thread-local storage.\nEmulates calling the internal _<em>rust</em>* allocator functions\nReturns the alignment that <code>malloc</code> would guarantee for …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nTry to get an environment variable from the interpreted …\nCalls <code>U::from(self)</code>.\nA unique id for file descriptions. While we could use the …\nThe file descriptor table\nStructure contains both the file description and its …\nRepresents an open file description.\nLike /dev/null\nHolds a weak reference to the actual file description.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert a new file description to the FdTable.\nInsert a file description, giving it a file descriptor …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnique identifier for file description, used to …\nReads as much as possible into the given buffer <code>ptr</code>. <code>len</code> …\nHelper to implement <code>FileDescription::read</code>: This is only …\nHelper to implement <code>FileDescription::write</code>: This function …\nSeeks to the given offset (which can be relative to the …\nWrites as much as possible from the given buffer <code>ptr</code>. <code>len</code> …\nType of dynamic symbols (for <code>dlsym</code> et al)\nCheck some basic requirements for this allocation request: …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEmulates a call to a <code>DynSym</code>.\nEmulates calling a foreign item, failing if the item is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLookup the body of a function that has <code>link_name</code> as the …\nA representation of an IO error: either a libc error name, …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nGets the last error variable.\nCalls <code>U::from(self)</code>.\nThis function tries to produce the most similar OS error …\nGet last error variable as a place, lazily allocating …\nSets the last error variable.\nSets the last OS error and writes -1 to dest place.\nSets the last OS error and return <code>-1</code> as a <code>i32</code>-typed Scalar\nSets the last OS error and return <code>-1</code> as a <code>i64</code>-typed Scalar\nThe inverse of <code>io_error_to_errnum</code>.\nHelper function that consumes an <code>std::io::Result&lt;T&gt;</code> and …\nEnum of supported arguments to external C functions.\nisize.\n16-bit signed integer.\n32-bit signed integer.\n64-bit signed integer.\n8-bit signed integer.\nRaw pointer, stored as C’s <code>void*</code>.\n16-bit unsigned integer.\n32-bit unsigned integer.\n64-bit unsigned integer.\n8-bit unsigned integer.\nusize.\nConvert a <code>CArg</code> to a <code>libffi</code> argument type.\nCall the native host function, with supplied arguments. …\nCall native host function and return the output as an …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nGet the pointer to the function of the specified name in …\nExtract the scalar value from the result of reading a …\nCalls <code>U::from(self)</code>.\nRepresent how path separator conversion should be done.\nAllocate enough memory to store the given <code>OsStr</code> as a …\nAllocate enough memory to store the given <code>OsStr</code> as a …\nAllocate enough memory to store a Path as a …\nAllocate enough memory to store a Path as a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHelper function to read an OsString from a null-terminated …\nHelper function to read an OsString from a …\nRead a null-terminated sequence of bytes, and perform path …\nRead a null-terminated sequence of <code>u16</code>s, and perform path …\nHelper function to write an OsStr as a null-terminated …\nHelper function to write an OsStr as a 0x0000-terminated …\nInternal helper to share code between …\nLike <code>write_os_str_to_wide_str</code>, but on failure as much as …\nWrite a Path to the machine memory (as a null-terminated …\nWrite a Path to the machine memory (as a null-terminated …\nWrite a Path to the machine memory (as a null-terminated …\nHolds all of the relevant data for when unwinding hits a …\nThe <code>catch_fn</code> callback to call in case of a panic.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe <code>data</code> argument for that callback.\nThe return place from the original call to <code>try</code>.\nReturns the argument unchanged.\nHandles the <code>try</code> intrinsic, the underlying implementation …\nHandles the special <code>miri_start_unwind</code> intrinsic, which is …\nCalls <code>U::from(self)</code>.\nThe return block from the original call to <code>try</code>.\nStart a panic in the interpreter with the given message as …\nStart a non-unwinding panic in the interpreter with the …\nReturns the time elapsed between the provided time and the …\nFor Windows Dtors, we store the list of functions that we …\nAdd a thread local storage destructor for the given …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nGenerate a new TLS key with the given destructor. <code>max_size</code> …\nThe data for this key. None is used to represent NULL. (We …\nDelete all TLS entries for the given thread. This function …\nReturns a dtor, its argument and its index, if one is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\npthreads-style thread-local storage.\nThe last TlsKey used to retrieve a TLS destructor. <code>None</code> …\nSchedule TLS destructors for Windows. On windows, TLS …\nOn macOS, each thread holds a list of destructor functions …\nThe Key to use for the next thread-local allocation.\nSchedule the macOS thread local storage destructors to be …\nSchedule a pthread TLS destructor. Returns <code>true</code> if found a …\nGeneral management of file descriptors, and support for …\nFile and file system access\nThis is an incomplete implementation of mmap/munmap which …\nThis implements “anonymous” sockets, that do not …\nAllocates an <code>environ</code> block with the given list of pointers.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPlace where the <code>environ</code> static is stored. Lazily …\nReturns the argument unchanged.\nImplementation detail for <code>InterpCx::get_env_var</code>. This …\nCalls <code>U::from(self)</code>.\nStores pointers to the environment variables. These …\nUpdates the <code>environ</code> static.\nRepresents unix-specific file descriptions.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCheck the readiness of file description.\nCalls <code>U::from(self)</code>.\nReads as much as possible into the given buffer <code>ptr</code> from a …\nWrites as much as possible from the given buffer <code>ptr</code> …\nRead data from <code>fd</code> into buffer specified by <code>buf</code> and <code>count</code>.\nThe table of open directories. Curiously, Unix/POSIX does …\nStores a file’s metadata in order to avoid code …\nAn open directory, tracked by DirHandler.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe most recent entry returned by readdir(). Will be freed …\nExtracts the number of seconds and nanoseconds elapsed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nID number to be used by the next call to opendir\nThe directory reader on the host.\nDirectory iterators used to emulate libc “directory …\nThis follows the pattern in src/shims/unix/mem.rs: We only …\nLinux <code>eventfd</code> implementation.\nAn <code>Epoll</code> file descriptor connects file handles and epoll …\nEpollEventInstance contains information that will be …\nEpollEventInterest registers the file description …\nThe table of all EpollEventInterest. The BTreeMap key is …\nEpollReadyEvents reflects the readiness of a file …\nThis helper function checks whether an epoll notification …\nFor a specific file description, get its ready events and …\nThe release clock associated with this event.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nOriginal data retrieved from <code>epoll_event</code> during <code>epoll_ctl</code>.\nThe data retrieved from <code>epoll_event</code>. libc’s data field …\nThis function returns a file descriptor referring to the …\nThis function performs control operations on the <code>Epoll</code> …\nThe <code>epoll_wait()</code> system call waits for events on the <code>Epoll</code> …\nError condition happened on the associated file descriptor.\nFor stream socket, this event merely indicates that the …\nThe associated file is available for read(2) operations, …\nThe associated file is available for write(2) operations, …\nStream socket peer closed connection, or shut down writing …\nXor-ed event types that happened to the file description.\nThe events bitmask retrieved from <code>epoll_event</code>.\nThe file descriptor value of the file description …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA map of EpollEventInterests registered under this epoll …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA map of EpollEventInstance that will be returned when …\nReady list of the epoll instance under which this …\nThis function takes in ready list and returns …\nStores the ready list of the <code>epfd</code> epoll instance into …\nA list of thread ids blocked on this epoll instance.\nThe epoll file description that this EpollEventInterest is …\nA kind of file descriptor created by <code>eventfd</code>. The <code>Event</code> …\nMaximum value that the eventfd counter can hold.\nA list of thread ids blocked on eventfd::read.\nA list of thread ids blocked on eventfd::write.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe object contains an unsigned 64-bit integer (uint64_t) …\nThis function creates an <code>Event</code> that is used as an event …\nBlock thread if the current counter is 0, else just return …\nBlock thread if the value addition will exceed u64::MAX -1,\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRead the counter in the buffer and return the counter if …\nA write call adds the 8-byte integer value supplied in its …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nImplementation of the SYS_futex syscall. <code>args</code> is the …\nCalls <code>U::from(self)</code>.\nContains macOS-specific synchronization functions.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe mutex kind.\nTo differentiate “the mutex kind has not been changed” …\nDo a bytewise comparison of the two places, using relaxed …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nTranslates the clock from what is stored in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEagerly create and initialize a new mutex.\nReturns the mutex data stored at the address that <code>mutex_ptr</code>…\nTo ensure an initialized mutex that was moved somewhere …\nReturns the kind of a static initializer.\nTranslates the mutex kind from what is stored in …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet the name of the specified thread. If the thread name …\nSet the name of the specified thread. If the name …\nOne end of a pair of connected unnamed sockets.\nThe maximum capacity of the socketpair buffer in bytes. …\nRead from AnonSocket and return the number of bytes read.\nWrite to AnonSocket based on the space available and …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>AnonSocket</code> file descriptor that is our “peer”, and …\nIndicates whether the peer has lost data when the file …\nThe buffer we are reading from, or <code>None</code> if this is the …\nFor more information on the arguments see the socketpair …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nImplementation detail for <code>InterpCx::get_env_var</code>.\nCalls <code>U::from(self)</code>.\nStores the environment variables.\nMiri representation of a Windows <code>HANDLE</code>\nErrors that can occur when constructing a <code>Handle</code> from a …\nCan’t convert scalar to handle because it is …\nThere is no thread with the given ID.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nsee docs for <code>to_packed</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a handle into its machine representation.\nConvert a scalar into a structured <code>Handle</code>. Structurally …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if we were succssful, <code>false</code> if we would block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComparison\nShift left, logically (shift in zeros) – same as shift …\nMaximum value (with SSE semantics)\nMinimum value (with SSE semantics)\nApproximation of 1/x\nShift right, arithmetically (shift in sign)\nShift right, logically (shift in zeros)\nApproximation of 1/sqrt(x)\nPerforms <code>which</code> scalar operation on <code>left</code> and <code>right</code> and …\nPerforms <code>which</code> operation on each component of <code>left</code> and …\nPerforms <code>which</code> operation on the first component of <code>left</code> …\nCalcultates either <code>a + b + cb_in</code> or <code>a - b - cb_in</code> …\nConvert from the <code>imm</code> argument used to specify the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nConditionally multiplies the packed floating-point …\nConverts each element of <code>op</code> from floating point to signed …\nTakes a 128-bit vector, transmutes it to <code>[u64; 2]</code> and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHorizontally performs <code>which</code> operation on adjacent values of\nCalculates absolute value of integers in <code>op</code> and stores the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConditionally loads from <code>ptr</code> according the high bit of each\nConditionally stores into <code>ptr</code> according the high bit of …\nCompute the sum of absolute differences of quadruplets of …\nPacks two N-bit integer vectors to a single N/2-bit …\nConverts two 32-bit integer vectors to a single 16-bit …\nConverts two 16-bit integer vectors to a single 8-bit …\nConverts two 32-bit integer vectors to a single 16-bit …\nConverts two 16-bit signed integer vectors to a single …\nPerform a carry-less multiplication of two 64-bit …\nMultiplies packed 16-bit signed integer values, truncates …\nNegates elements from <code>left</code> when the corresponding element …\nGets equivalent <code>rustc_apfloat::Round</code> from rounding mode …\nImplements sha256 SIMD instructions of x86 targets\nShifts each element of <code>left</code> by a scalar amount. The shift …\nShifts each element of <code>left</code> by the corresponding element …\nSplits <code>op</code> (which must be a SIMD vector) into 128-bit …\nCalculates two booleans.\nCalculates two booleans.\nPerforms <code>which</code> scalar operation on <code>op</code> and returns the …\nPerforms <code>which</code> operation on each component of <code>op</code>, storing …\nPerforms <code>which</code> operation on the first component of <code>op</code> and …\nResult when lhs == rhs\nResult when lhs &lt; rhs\nResult when lhs &gt; rhs\nResult when lhs is NaN or rhs is NaN\nA lookup table for computing the inverse byte for the …\nCalculates the affine transformation <code>right * left + imm8</code> …\nMultiplies packed 8-bit integers in <code>left</code> and <code>right</code> in the …\nA bitmask constant for scrutinizing the immediate byte …\nA bitmask constant for scrutinizing the immediate byte …\nThe main worker for the string comparison intrinsics, …\nObtain the arguments of the intrinsic based on its name. …\nCalculate the c-style string length for a given string <code>str</code>.")