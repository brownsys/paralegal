searchState.loadedDescShard("rustc_abi", 0, "A pair of alignments, ABI-mandated and preferred.\nAn identifier that specifies the address space that some …\nAlignment of a type in bytes (always a power of two).\nA tuple, closure, or univariant which cannot be coerced to …\nStruct-like placement, with precomputed offsets.\nArray/vector-like placement, with all fields of identical …\nThe way we represent values to the backend\nBox. <code>unpin</code> indicates the absence of any pinned data. <code>global</code>…\nThe default address space, corresponding to data space.\nThe tag directly stores the discriminant, but possibly …\nA union had no fields.\nEndianness of the target, which must match …\nEquivalent to <code>VariantIdx(0)</code>.\nThe <em>source-order</em> index of a field in a variant.\nDescribes how the fields of a type are located in memory.\nFixed-sized integer type, e.g. <code>i8</code>, <code>u32</code>, <code>i128</code>. The bool …\nFloating-point types.\nRequirements for a <code>StableHashingContext</code> to be used in this …\nError from the <code>homogeneous_aggregate</code> test function, …\nYes, all the “leaf fields” of this struct are passed …\nReturn value from the <code>homogeneous_aggregate</code> test function.\nThe <code>bool</code> is the signedness of the <code>Integer</code> type.\nIntegers, also used for enum discriminants.\nA univariant, the last field of which may be coerced to …\nEnum-likes with more than one variant: each variant comes …\nMutable reference. <code>unpin</code> indicates the absence of any …\nNiche (values invalid for a type) encoding the …\nThere are no leaf fields at all.\nEncodes extra information we have about a pointer. Note …\nPointer-sized integer type, i.e. <code>isize</code> and <code>usize</code>. The …\nA univariant, but with a prefix of an arbitrary size &amp; …\nFundamental unit of memory access and layout.\nScalar primitives and <code>!</code>, which never have fields.\nThe fields or variants have irreconcilable reprs\nRepresents the repr options provided by the user.\nFor things unlikely to be called, where reducing register …\nInformation about one scalar component of a Rust type.\nShared reference. <code>frozen</code> indicates the absence of any …\nSingle enum variants, structs/tuples, unions, and all …\nSize of a type in bytes.\nA type was too large for the target platform.\nParsed Data layout for a target, which contains everything …\nTrait that needs to be implemented by the higher-level …\nThe layout of a type, alongside the type itself. Provides …\n<em>Not</em> a stable ABI, just directly use the Rust types to …\nAn unsized type was found in a location where a sized type …\nAll fields start at no offset. The <code>usize</code> is the field …\nThe <em>source-order</em> index of a variant in a type.\nInclusive wrap-around range of valid values, that is, if …\nIf <code>safe</code> is <code>Some</code>, then the pointer is aligned as indicated.\nGet a flags value with all known bits set.\nFind the largest integer with the given alignment or less.\nThe <code>backend_repr</code> defines how this data will be represented …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nMinimum size of #[repr(C)] enums (default c_int::BITS, …\nReturns <code>true</code> if this type is valid for reordering and …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nReturns <code>true</code> if <code>v</code> is contained in the range.\nCreates an instance of <code>TargetDataLayout</code>.\nThe intersection of a source flags value with the …\nReturns the discriminant type, given these <code>repr</code> options. …\nGet a flags value with all bits unset.\nChecks if these two <code>Layout</code> are equal enough to be …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe seed to be used for randomizing a type’s layout\nSays where the fields are located within the layout.\nFinds the smallest Integer type which can represent the …\nFinds the smallest Integer type which can represent the …\nFinds the smallest integer with the given alignment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the Integer type from an IntegerType.\nConvert from a bits value.\nRounds <code>bits</code> up to the next-higher byte boundary, if <code>bits</code> is\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGets source indices of the fields by increasing offsets.\nReturns the fixed alignment of this ABI, if any is …\nReturns the fixed size of this ABI, if any is mandated.\nReturns <code>true</code> if this <code>#[repr()]</code> should inhabit “smart enum\nReturns <code>true</code> if this <code>#[repr()]</code> guarantees a fixed field …\nReturns <code>true</code> if this <code>#[repr()]</code> should inhibit union ABI …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the type is sized and a 1-ZST (meaning it …\nReturns <code>true</code> if this is an aggregate type (including a …\nWhether all known bits in this flags value are set.\nReturns <code>true</code> if all possible numbers are valid, i.e …\nReturns <code>true</code> if this is a bool\nWhether all bits in this flags value are unset.\nReturns <code>true</code> if <code>size</code> completely fills the range.\nReturns <code>true</code> if this is a scalar type\nReturns <code>true</code> if this is a signed integer scalar\nReturns <code>true</code> if this is a single signed integer scalar\nReturns <code>true</code> if this is an uninhabited type\nReturns <code>true</code> if this is an uninhabited type\nReturns <code>true</code> if this type can be left uninit.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the type is a ZST and not unsized.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe leaf scalar with the largest number of invalid values …\nReturns the ABI with the given name (if any).\nComputes the best alignment possible for the given offset …\nThe largest alignment explicitly requested with <code>repr(align)</code>…\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns <strong>exclusive</strong> upper bound on object size in bytes.\nParse data layout from an llvm data layout string\nGet the primitive representation of this type, ignoring …\nThe intersection of a source flags value with the …\nLower the alignment, if necessary, such that the given …\nIf this is <code>None</code>, then this is a raw pointer, so size and …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nTruncates <code>value</code> to <code>self</code> bits and then sign-extends it to …\nReturns the largest signed value that can be represented …\nIf <code>safe</code> is <code>Some</code>, then the pointer is either null or …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nDiscard validity range information and allow undef.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTruncates <code>value</code> to <code>self</code> bits.\nThe alignment the type would have, ignoring any <code>repr(align)</code>…\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nAllows the caller to mutate the valid range. This …\nEncodes information about multi-variant layouts. Even with …\nAlignments for vector types.\nReturns <code>self</code> with replaced <code>end</code>\nReturns <code>self</code> with replaced <code>start</code>\nIf true, the size is exact, otherwise it’s only a lower …\nMaps source order field indices to memory order indices, …\nOffsets for the first byte of each field, ordered to match …\nEven for unions, we need to use the correct registers for …\nThis is inbounds of the type of the niche field (not …\nThis range <em>may</em> contain <code>untagged_variant</code>; that is then just …\nAlways 0 for non-enums/generators. For enums without a …\nError from the <code>homogeneous_aggregate</code> test function, …\nYes, all the “leaf fields” of this struct are passed …\nReturn value from the <code>homogeneous_aggregate</code> test function.\nThere are no leaf fields at all.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to combine two <code>HomogeneousAggregate</code>s, e.g. from two …\nIf this is a homogeneous aggregate, returns the homogeneous\nDefault ABI chosen for <code>extern fn</code> declarations without an …\nFor things unlikely to be called, where reducing register …\n<em>Not</em> a stable ABI, just directly use the Rust types to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the ABI with the given name (if any).\nName of this ABI as we like it called.\nA union had no fields.\nContains the error value\nDetermines towards which end of a struct layout …\nContains the success value\nThe fields or variants have irreconcilable reprs\nA type was too large for the target platform.\nAn unsized type was found in a location where a sized type …\nFormat an untranslated diagnostic for this type\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nsingle-variant enums are just structs, if you think about …\nEquivalent to <code>VariantIdx(0)</code>.\nThe <em>source-order</em> index of a field in a variant.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nTrait that needs to be implemented by the higher-level …\nThe layout of a type, alongside the type itself. Provides …\nThe <em>source-order</em> index of a variant in a type.\nZero value of the index.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nReturns <code>Homogeneous</code> if this layout is an aggregate …\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the layout is from a type that implements …\nFinds the one field that is not a 1-ZST. Returns <code>None</code> if …")