searchState.loadedDescShard("clippy_config", 0, "Clippy lint configuration\nWhich crates to allow absolute paths from\nThe maximum number of segments a path can have before …\nWhether to accept a safety comment to be placed above the …\nWhether to accept a safety comment to be placed above the …\nDon’t lint when comparing the result of a modulo …\nWhether <code>dbg!</code> should be allowed in test functions or …\nWhether <code>expect</code> should be allowed in test functions or …\nWhether to allow mixed uninlined format args, e.g. …\nWhether to allow <code>r#&quot;&quot;#</code> when <code>r&quot;&quot;</code> can be used\nWhether <code>panic</code> should be allowed in test functions or …\nWhether print macros (ex. <code>println!</code>) should be allowed in …\nWhether to allow module inception if it’s not public.\nList of trait paths to ignore when checking renamed …\nWhether <code>unwrap</code> should be allowed in test functions or …\nWhether <code>useless_vec</code> should ignore test functions or …\nAdditional dotfiles (files or directories starting with a …\nA list of crate names to allow duplicates of\nAllowed names below the minimum allowed characters. The …\nList of prefixes to allow when determining whether an item…\nThe list of unicode scripts allowed to be used in the …\nList of path segments allowed to have wildcard imports.\nSuppress checking of the passed type names in all types of …\nSuppress checking of the passed type pair names in binary …\nSuppress checking of the passed type names in unary …\nThe maximum allowed size for arrays on the stack\nSuppress lints whenever the suggested change would cause …\nThe list of types which may not be held across an await …\nDEPRECATED LINT: BLACKLISTED_NAME.\nFor internal testing only, ignores the current <code>publish</code> …\nWhether to also run the listed lints on private items.\nThe maximum cognitive complexity a function can have\nDEPRECATED LINT: CYCLOMATIC_COMPLEXITY.\nThe list of disallowed macros, written as fully qualified …\nThe list of disallowed methods, written as fully qualified …\nThe list of disallowed names to lint about. NB: <code>bar</code> is not …\nThe list of disallowed types, written as fully qualified …\nThe list of words this lint should not consider as …\nWhether to apply the raw pointer heuristic to determine if …\nWhether to recommend using implicit into iter for …\nThe list of imports to always rename, a fully qualified …\nThe minimum number of enum variants for the lints about …\nThe maximum size of an enum’s variant to avoid box …\nThe maximum amount of nesting a block can reside in\nThe maximum byte size a <code>Future</code> can have, before it …\nA list of paths to types that should be treated as if they …\nThe maximum size of the <code>Err</code>-variant in a <code>Result</code> returned …\nThe lower bound for linting decimal literals\nSearch for the configuration file.\nWhether the matches should be considered by the lint, and …\nThe maximum number of bool parameters a function can have\nThe maximum size of a file included via <code>include_bytes!()</code> …\nThe maximum number of bool fields a struct can have\nWhen Clippy suggests using a slice pattern, this is the …\nThe maximum number of bounds a trait can have to be linted\nMinimum chars an ident can have, anything below or equal …\nWhether to <strong>only</strong> check for missing documentation in items …\nThe named groupings of different source item kinds within …\nThe minimum rust version that the project supports. …\nThe minimum size (in bytes) to consider a type for passing …\nLint “public” fields in a struct that are prefixed …\nWhether to lint only if it’s multiline.\nWhether to lint only if it’s singleline.\nThe maximum number of single char bindings a scope may have\nWhich kind of elements should be ordered internally, …\nThe maximum allowed stack size for functions in bytes\nEnforce the named macros always use the braces specified.\nThe minimum number of struct fields for the lints about …\nWhether to suppress a restriction lint in constant code. …\nThe maximum size of objects (in bytes) that will be …\nThe maximum number of argument a function or method can …\nThe maximum number of lines a function or method can have\nThe order of associated items in traits.\nThe maximum size (in bytes) to consider a <code>Copy</code> type for …\nThe maximum complexity a type can have\nThe byte size a <code>T</code> in <code>Box&lt;T&gt;</code> can have, below which it …\nShould the fraction of a decimal be linted to include …\nEnables verbose mode. Triggers if there is more than one …\nThe size of the boxed type in bytes, where boxing in a <code>Vec</code> …\nThe maximum allowed size of a bit mask before suggesting …\nWhether to allow certain wildcard imports (prelude, super …\nWhether to also emit warnings for unsafe blocks with …\nClippy lint configuration\nConf with parse errors\nWhich crates to allow absolute paths from\nThe maximum number of segments a path can have before …\nWhether to accept a safety comment to be placed above the …\nWhether to accept a safety comment to be placed above the …\nDon’t lint when comparing the result of a modulo …\nWhether <code>dbg!</code> should be allowed in test functions or …\nWhether <code>expect</code> should be allowed in test functions or …\nWhether to allow mixed uninlined format args, e.g. …\nWhether to allow <code>r#&quot;&quot;#</code> when <code>r&quot;&quot;</code> can be used\nWhether <code>panic</code> should be allowed in test functions or …\nWhether print macros (ex. <code>println!</code>) should be allowed in …\nWhether to allow module inception if it’s not public.\nList of trait paths to ignore when checking renamed …\nWhether <code>unwrap</code> should be allowed in test functions or …\nWhether <code>useless_vec</code> should ignore test functions or …\nAdditional dotfiles (files or directories starting with a …\nA list of crate names to allow duplicates of\nAllowed names below the minimum allowed characters. The …\nList of prefixes to allow when determining whether an item…\nThe list of unicode scripts allowed to be used in the …\nList of path segments allowed to have wildcard imports.\nSuppress checking of the passed type names in all types of …\nSuppress checking of the passed type pair names in binary …\nSuppress checking of the passed type names in unary …\nThe maximum allowed size for arrays on the stack\nSuppress lints whenever the suggested change would cause …\nThe list of types which may not be held across an await …\nDEPRECATED LINT: BLACKLISTED_NAME.\nFor internal testing only, ignores the current <code>publish</code> …\nWhether to also run the listed lints on private items.\nThe maximum cognitive complexity a function can have\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nDEPRECATED LINT: CYCLOMATIC_COMPLEXITY.\nThe list of disallowed macros, written as fully qualified …\nThe list of disallowed methods, written as fully qualified …\nThe list of disallowed names to lint about. NB: <code>bar</code> is not …\nThe list of disallowed types, written as fully qualified …\nThe list of words this lint should not consider as …\nWhether to apply the raw pointer heuristic to determine if …\nWhether to recommend using implicit into iter for …\nThe list of imports to always rename, a fully qualified …\nThe minimum number of enum variants for the lints about …\nThe maximum size of an enum’s variant to avoid box …\nThe maximum amount of nesting a block can reside in\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe maximum byte size a <code>Future</code> can have, before it …\nA list of paths to types that should be treated as if they …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum size of the <code>Err</code>-variant in a <code>Result</code> returned …\nThe lower bound for linting decimal literals\nSearch for the configuration file.\nWhether the matches should be considered by the lint, and …\nThe maximum number of bool parameters a function can have\nThe maximum size of a file included via <code>include_bytes!()</code> …\nThe maximum number of bool fields a struct can have\nWhen Clippy suggests using a slice pattern, this is the …\nThe maximum number of bounds a trait can have to be linted\nMinimum chars an ident can have, anything below or equal …\nWhether to <strong>only</strong> check for missing documentation in items …\nThe named groupings of different source item kinds within …\nThe minimum rust version that the project supports. …\nThe minimum size (in bytes) to consider a type for passing …\nLint “public” fields in a struct that are prefixed …\nWhether to lint only if it’s multiline.\nWhether to lint only if it’s singleline.\nThe maximum number of single char bindings a scope may have\nWhich kind of elements should be ordered internally, …\nThe maximum allowed stack size for functions in bytes\nEnforce the named macros always use the braces specified.\nThe minimum number of struct fields for the lints about …\nWhether to suppress a restriction lint in constant code. …\nThe maximum size of objects (in bytes) that will be …\nThe maximum number of argument a function or method can …\nThe maximum number of lines a function or method can have\nThe order of associated items in traits.\nThe maximum size (in bytes) to consider a <code>Copy</code> type for …\nThe maximum complexity a type can have\nThe byte size a <code>T</code> in <code>Box&lt;T&gt;</code> can have, below which it …\nShould the fraction of a decimal be linted to include …\nEnables verbose mode. Triggers if there is more than one …\nThe size of the boxed type in bytes, where boxing in a <code>Vec</code> …\nThe maximum allowed size of a bit mask before suggesting …\nWhether to allow certain wildcard imports (prelude, super …\nWhether to also emit warnings for unsafe blocks with …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents which item categories are enabled for ordering.\nRepresents the item categories that can be ordered by the …\nRepresents the configured ordering of items within a …\nRepresents the items that can occur within a module.\nRepresents all kinds of trait associated items.\nRepresents the order in which associated trait items …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCreates a map of disallowed items to the reason they were …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")