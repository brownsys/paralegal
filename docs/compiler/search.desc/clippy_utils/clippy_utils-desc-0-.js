searchState.loadedDescShard("clippy_utils", 0, "Borrow expression.\nBinary operation traits like <code>LangItem::Add</code>\nThe callee of a function call.\nHow a local is captured by a closure\nInitializer for a const or static item.\nA type definition as it would be viewed from within a …\nThe context an expressions value is used in.\nThe node which consumes a value.\nInitialization of a struct field.\nAccess of a field.\nAn argument to a function.\nAssignment to, or initializer for, a local\nAn argument to a method.\nArguments of a method: the receiver and all the additional …\nUsed for function signatures, and constant and static …\nOperator-Assign traits like <code>LangItem::AddAssign</code>\nImplicit or explicit return from a function.\nType used to check whether two ast are the same. This is …\nType used to hash an ast element. This is different from …\nAny adjustments applied to the type.\nUtilities for manipulating and extracting information from …\nReturns true if the given <code>expr</code> is binary expression that …\nConverts <code>BinOpKind::Add</code> to …\nChecks if the two <code>Option</code>s are both <code>None</code> or some equal …\nChecks if the expression can be moved into a closure as …\nChecks if the top level expression can be moved into a …\nChecks if two expressions can be mutably borrowed …\nGiven an expression referencing a local, determines how it …\nThis module handles checking if the span given is from a …\nThe child id of the node the value came from.\nclip unused bytes\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nUtility functions for comparison operators.\nA simple const eval API, for use on arbitrary HIR …\nChecks if an <code>Expr</code> contains a certain name.\nReturns <code>true</code> if <code>expr</code> contains a return expression\nCounts how many elements of the slices are equal as per …\nContext used to evaluate constant expressions.\nContext used to evaluate constant expressions.\nResolves a def path like <code>std::vec::Vec</code> to its <code>DefId</code>s, see …\nResolves a def path like <code>std::vec::Vec</code>.\nResolves a def path like <code>vec::Vec</code> with the base <code>std</code>.\nGets the needed type as it’s defined without any type …\nClippy wrappers around rustc’s diagnostic functions.\nUtilities for evaluating whether eagerly evaluated …\nChecks if two expressions evaluate to the same value, and …\nGets the mutability of the custom deref adjustment, if any.\nIf the given expression is a local binding, find the …\nGets the context an expression’s value is used in.\nFinds the initializer expression for a local binding. …\nFinds the crates called <code>name</code>, may be multiple due to …\nReturns the <code>DefId</code> of the callee if the given expression is …\nReturns the <code>DefId</code> of the callee if the given expression is …\nCheck if it’s even possible to satisfy the <code>where</code> clause …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if the lint is <code>#[allow]</code>ed or <code>#[expect]</code>ed at …\nPeels away all the compiler generated code surrounding the …\nGets the enclosing block, if any.\nGets the loop or closure enclosing the given expression, …\nGets the node where an expression is either used, or it’…\nGets the name of the item the expression is in, if …\nGets the parent node if it’s an impl block.\nGets the parent expression, if any –- this is useful to …\nThis retrieves the parent for the given <code>HirId</code> if it’s an …\nProduces a path from a local caller to the type of the …\nProduce a path from some local caller to the callee. …\nConvenience function to get the <code>DefId</code> of a trait by path. …\nThis module contains functions that retrieve specific …\nReturns the list of condition expressions and the list of …\nChecks if the given HIR node is inside an <code>impl</code> block with …\nChecks if the item of any of its parents has <code>#[cfg(...)]</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given <code>Expr</code> has been coerced before.\nChecks if the given function kind is an async function.\nReturns true if the given <code>expr</code> is a block or resembled as …\nChecks if a function’s body represents the identity …\nChecks if <code>id</code> has a <code>#[cfg(test)]</code> attribute applied\nChecks if an expression is constructing a tuple-like enum …\nChecks if the <code>def_id</code> belongs to a function that is part of …\nReturns true if the expr is equal to <code>Default::default()</code> of …\nReturns true if the expr is equal to <code>Default::default</code> when …\nReturns true if the <code>def_id</code> associated with the <code>path</code> is …\nChecks if a method is defined in an impl of a diagnostic …\nChecks if a method is in a diagnostic item trait\nChecks if the <code>DefId</code> matches the given diagnostic item or it…\nReturns the pre-expansion span if the span directly comes …\nChecks if the given expression is the else clause of …\nChecks if the given expression is the else clause of a …\nReturns <code>true</code> if the provided <code>def_id</code> is an entrypoint to a …\nChecks if <code>{ctor_call_id}(...)</code> is …\nReturns the pre-expansion span if this comes from an …\nChecks if the expression is the final expression returned …\nChecks if an expression represents the identity function …\nIf the expression is a path, resolves it to a <code>DefId</code> and …\nThis is the same as <code>is_expr_identity_function</code>, but does …\nChecks if the result of an expression is used, or it’s …\nChecks if the item likely came from a proc-macro.\nChecks if any parent node of <code>HirId</code> has <code>#[cfg(test)]</code> …\nChecks if we are currently in a const context (e.g. …\nReturns <code>true</code> if the expression is in the program’s …\nChecks if the node is in a <code>#[test]</code> function or has any …\nChecks if the function containing the given <code>HirId</code> is a …\nChecks if the given method call expression calls an …\nReturns <code>true</code> if the given <code>HirId</code> is inside an always …\nChecks if the given expression is a part of <code>let else</code> …\nChecks whether the given expression is a constant integer …\nChecks whether the given expression is a constant literal …\nChecks if the <code>DefId</code> matches the given <code>LangItem</code> or it’s …\nReturns <code>true</code> if the lint is allowed in the current …\nCheck if the expression return <code>!</code>, a type coerced from <code>!</code>, …\nReturns true if the specified <code>HirId</code> is the top-level …\nIf <code>maybe_path</code> is a path node which resolves to an item, …\nIf <code>maybe_path</code> is a path node which resolves to an item, …\nChecks whether the given <code>Expr</code> is a range equivalent to a …\nReturns true if the specified expression is in a receiver …\nChecks if the value is used as a method call receiver.\nReturns <code>true</code> if a pattern is refutable.\nChecks if a <code>Res</code> refers to a constructor of a <code>LangItem</code> For …\nChecks if the value is returned from the function.\nReturns <code>Option&lt;String&gt;</code> where String is a textual …\nChecks if the span actually refers to an if expression\nChecks if the span actually refers to a match expression\nCheck if parent of a hir node is a trait implementation …\nChecks if the given expression is a path referring an item …\nChecks if the method call given in <code>expr</code> belongs to the …\nChecks if a given expression is a match expression …\nChecks if the given <code>QPath</code> belongs to a type alias.\nWhether the type must unify with another code path.\nChecks if given pattern is a wildcard (<code>_</code>)\nChecks if the given local has an initializer or is from …\nChecks if the given <code>DefId</code> matches any of the paths. …\nChecks if the given <code>DefId</code> matches the path.\nMatches a function call with the given path and returns …\nChecks if the given <code>DefId</code> matches the <code>libc</code> item.\nTHIS METHOD IS DEPRECATED. Matches a <code>Path</code> against a slice …\nTHIS METHOD IS DEPRECATED. Matches a <code>QPath</code> against a slice …\nChecks if the method call given in <code>expr</code> belongs to the …\nTries to produce a relative path from <code>from</code> to <code>to</code>; if such …\nReturns the method names and argument list of nested …\nMatches an <code>Expr</code> against a chain of methods, and return the …\nWhether the value will be moved before it’s used.\nThe parent node which consumes the value.\nConvenience function to get the nth argument type of a …\nChecks if two slices are equal as per <code>eq_fn</code>.\nReturns whether the given let pattern and else body can be …\nReturns <code>true</code> if the pattern is a <code>PatWild</code>, or is an ident …\nIf <code>maybe_path</code> is a path node which resolves to an item, …\nIf <code>maybe_path</code> is a path node, resolves it, otherwise …\nIf the expression is a path to a local, returns the …\nReturns true if the expression is a path to a local with …\nThis module contains paths to types and functions Clippy …\nRemoves blocks around an expression, only if the block …\nRemoves blocks around an expression, only if the block …\nPeels off all references on the expression. Returns the …\nPeels off all unary operators of an expression. Returns …\nPeels of expressions while the given closure returns <code>Some</code>.\nPeels off all references on the pattern. Returns the …\nPeels off all references on the type. Returns the …\nPeels off all references on the type. Returns the …\nPeels off up to the given number of references on the …\nRemoves <code>AddrOf</code> operators (<code>&amp;</code>) or deref operators (<code>*</code>), but …\nThis method will return tuple of projection stack and root …\nIf the pattern is an <code>or</code> pattern, call the function once …\nConvenience function to get the return type of a function.\nWhether the use site has the same <code>SyntaxContext</code> as the …\nReturns list of all pairs <code>(a, b)</code> where <code>eq(a, b) == true</code> …\nTurn a constant int byte representation into an i128\nUtils for extracting, inspecting or transforming source …\nChecks whether a given span has any comment token This …\nReturns all the comments a given span contains\nContains utility functions to generate suggestions.\nConvenience wrapper around rustc’s <code>Symbol::intern</code>\nTokenizes the input while keeping the text associated with …\nGets the <code>hir::TraitRef</code> of the trait the given method is …\nUtil methods for <code>rustc_middle::ty</code>\nclip unused bytes\nWalks up the HIR tree from the given expression in an …\nChecks if each element in the first slice is contained …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttribute is deprecated\nDeprecation status of attributes known by Clippy.\nAttribute is deprecated and was replaced by the named …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the attributes contain <code>#[doc(hidden)]</code>\nReturns true if the attributes contain any of <code>proc_macro</code>, …\nChecks if the given span contains a <code>#[cfg(..)]</code> attribute\nAny of the given strings.\nAny decimal or hexadecimal digit depending on the location.\nAny of the given strings.\nThe search pattern to look for. Used by <code>span_matches_pat</code>\nA single string.\nThe string representation of the symbol.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nGet the search patterns to use for the given expression\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if the item likely came from a proc-macro.\nChecks if the span actually refers to an if expression\nChecks if the span actually refers to a match expression\nGet the search patterns to use for the given literal\nGet the search patterns to use for the given path\nChecks if the start and the end of the span’s text …\n<code>==</code>\n<code>&lt;=</code>\n<code>&lt;</code>\n<code>!=</code>\nRepresents a normalized comparison operator.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPut the expression in the form  <code>lhs &lt; rhs</code>, <code>lhs &lt;= rhs</code>, …\nA binary string (e.g., <code>b&quot;abc&quot;</code>).\n<code>true</code> or <code>false</code>.\nA single <code>char</code> (e.g., <code>&#39;a&#39;</code>).\nThe context required to evaluate a constant expression.\nA <code>LitKind</code>-like enum to fold constant <code>Expr</code>s into.\nThe value is dependent on a defined constant.\nThe source of a constant value.\nThe value is dependent on a constant defined in <code>core</code> crate.\nA literal with syntax error.\nAn <code>f128</code>.\nAn <code>f16</code>.\nAn <code>f32</code>.\nAn <code>f64</code>.\nAn integer’s bit representation.\nThe value is determined solely from the expression.\nA raw pointer.\nA reference\nAlso an array, but with only one constant, repeated N …\nA <code>String</code> (e.g., “abc”).\nA tuple of constants.\nAn array of constants.\nA block can only yield a constant if it has exactly one …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAttempts to evaluate the expression.\nAttempts to evaluate the expression as an integer without …\nSimple constant folding to determine if an expression is …\nAttempts to evaluate the expression without accessing …\nAttempts to evaluate the expression and returns both the …\nSimple constant folding: Insert an expression, get a …\nLookup a possibly constant expression from an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the integer value or <code>None</code> if <code>self</code> or <code>val_type</code> is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParses a <code>LitKind</code> to a <code>Constant</code>.\nCreate <code>Some(Vec![..])</code> of all constants, unless there is any\nCreates the evaluation context from the lint context. This …\nCreates an evaluation context.\nEmit a basic lint message with a <code>msg</code> and a <code>span</code>.\nSame as <code>span_lint</code> but with an extra <code>help</code> message.\nLike <code>span_lint</code> but with a <code>note</code> section instead of a <code>help</code> …\nAdd a span lint with a suggestion on how to fix it.\nLike <code>span_lint</code> but allows to add notes, help and …\nLike <code>span_lint</code>, but emits the lint at the node identified …\nLike <code>span_lint_and_then</code>, but emits the lint at the node …\nMakes sure that a diagnostic is well formed.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nDetermine the eagerness of the given function call.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether the given expression should be changed to evaluate …\nWhether the given expression should be changed to evaluate …\n<code>Vec::default()</code> or <code>Default::default()</code>\nThe essential nodes of a desugared for loop as well as the …\nAn <code>if</code> expression without <code>DropTemps</code>\nAn <code>if let</code> expression\nscrutinee, pattern, then block, else block\nAn <code>if let</code> or <code>match</code> expression. Useful for lints that …\nAn <code>if</code> or <code>if let</code> expression\nAny <code>match</code> expression\n<code>Vec::new()</code>\nRepresent a range akin to <code>ast::ExprKind::Range</code>.\n<code>vec![elem; len]</code>\n<code>vec![a, b, c]</code>\nRepresents the pre-expansion arguments of a <code>vec!</code> …\nA parsed <code>Vec</code> initialization expression\nA desugared <code>while</code> loop\nA desugared <code>while let</code> loop\n<code>Vec::with_capacity(123)</code>\n<code>Vec::with_capacity(slice.len())</code>\n<code>IntoIterator</code> argument\nConverts a <code>hir</code> binary operator to the corresponding <code>ast</code> …\n<code>for</code> loop body\n<code>while</code> loop body\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\n<code>if</code> condition\n<code>if</code> condition that is maybe a <code>let</code> expression\n<code>while</code> loop condition\n<code>else</code> expression\n<code>else</code> expression\nThe upper bound of the range, or <code>None</code> for ranges such as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nChecks if the given expression is an initialization of <code>Vec</code> …\nParses a desugared <code>for</code> loop\nParses an <code>if</code> expression\nParses an <code>if let</code> expression\nParses an <code>if</code> or <code>if let</code> expression\nReturns the arguments of the <code>vec!</code> macro if this expression …\nParses a desugared <code>while</code> loop\nParses a desugared <code>while let</code> loop\nHigher a <code>hir</code> range to something similar to …\n<code>if let</code> else expression\n<code>if let</code> then expression\n<code>while let</code> loop body\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nlabel\n<code>if let</code> scrutinee\n<code>while let</code> loop scrutinee\n<code>if let</code> pattern\n<code>while let</code> loop item pattern\n<code>if let PAT = EXPR</code> ^^^^^^^^^^^^^^\n<code>while let PAT = EXPR</code> ^^^^^^^^^^^^^^\nWhether the interval is open or closed.\nCompare this against <code>hir::Destination.target</code>\nParses an <code>if let</code> or <code>match</code> expression\n<code>for</code> loop item\nentire <code>for</code> loop span\nSpan of the loop header\nThe lower bound of the range, or <code>None</code> for ranges such as …\n<code>if</code> then expression\n<code>if</code> then expression\nPaths must match exactly and are hashed by their exact HIR …\nDetermines how paths are hashed and compared for equality.\nPaths are compared and hashed based on their resolution.\nType used to check whether two ast are the same. This is …\nCallback that is called when two expressions are not equal …\nType used to hash an ast element. This is different from …\nChecks if the two <code>Option</code>s are both <code>None</code> or some equal …\nChecks if the two <code>Option</code>s are both <code>Some</code> and pass the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCounts how many elements of the slices are equal as per …\nContext used to evaluate constant expressions.\nContext used to evaluate constant expressions.\nConsider expressions containing potential side effects as …\nChecks whether two constraints designate the same equality …\nChecks whether two blocks are the same.\nChecks if two expressions evaluate to the same value, and …\nChecks whether two patterns are the same.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the segments of a path that might have generic …\nUse this method to wrap comparisons that may involve …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if two slices are equal as per <code>eq_fn</code>.\nCheck paths by their resolution instead of exact equality. …\nCheck paths by their resolution instead of exact equality. …\nSome simple reductions like <code>{ return }</code> =&gt; <code>return</code>\nAppears as an argument, e.g. <code>format!(&quot;{}&quot;, foo)</code>\nA single argument that implements <code>Display</code> - …\nNo arguments - <code>panic!()</code>\nAnything else - <code>panic!(&quot;error {}: {}&quot;, a, b)</code>\nStores AST <code>FormatArgs</code> nodes for use in late lint passes, …\nWhere a format parameter is being used in the format string\nA node with a <code>HirId</code> and a <code>Span</code>\nA macro call, like <code>vec![1, 2, 3]</code>.\nAppears as a precision, e.g. …\nA string literal or any <code>&amp;str</code> - <code>panic!(&quot;message&quot;)</code> or …\nAppears as a width, e.g. …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nMacro <code>DefId</code>\nThe expansion produced by the macro call\nReturns an iterator of expansions that created the given …\nChecks whether the expansion is the root expansion or a …\nFinds the arguments of an <code>assert!</code> or <code>debug_assert!</code> macro …\nFinds the arguments of an <code>assert_eq!</code> or <code>debug_assert_eq!</code> …\nAttempt to find the <code>rustc_hir::Expr</code> that corresponds to …\nIf <code>node</code> is the “first node” in a macro expansion, …\nLike <code>macro_backtrace</code>, but only returns macro calls where …\nReturns the <code>Span</code> of the value at <code>index</code> extended to the …\nSpan covering the format string and values\nSpan of the <code>:</code> and format specifiers\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns an AST <code>FormatArgs</code> node if a <code>format_args</code> expansion …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>def_id</code> of <code>assert!</code> or <code>debug_assert!</code>\nReturns true if a given Macro <code>DefId</code> is a format macro …\nIs <code>def_id</code> of <code>std::panic</code>, <code>core::panic</code> or any inner …\nKind of macro\nReturns an iterator of macro expansions that created the …\nA combination of <code>root_macro_call</code> and <code>is_diagnostic_item</code> …\nIf the macro backtrace of <code>span</code> has a macro call at the …\nLike <code>root_macro_call</code>, but only returns <code>Some</code> if <code>node</code> is the …\nShould only be called by <code>FormatArgsCollector</code>\nSpan of the macro call site\nChecks whether the span is from the root expansion or a …\nResult of <code>PossibleBorrowerVisitor</code>.\nChecks if the block is part of a cycle\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the <code>mir::Body</code> containing the node associated with …\nTries to determine the <code>Local</code> corresponding to <code>expr</code>, if any.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a vector of <code>mir::Location</code> where <code>local</code> is assigned.\nThe locations where the local is consumed or mutated, if …\nThe locations where the local is used, if any.\nMapping <code>Local -&gt; its possible borrowers</code>\nConvenience wrapper around <code>visit_local_usage</code>.\nResult of <code>PossibleBorrowerVisitor</code>.\nCollects the possible borrowers of each local. For …\nReturns true if the set of borrowers of <code>borrowed</code> living at …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMapping <code>Local -&gt; its possible borrowers</code>\nReturns true if the set of borrowers of <code>borrowed</code> living at …\nCollect possible borrowed for every <code>&amp;mut</code> local. For …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTracks the current MSRV from <code>clippy.toml</code>, <code>Cargo.toml</code> or …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe exponent separator (b’e’ or b’E’) including …\nA helper method to format numeric literals with digit …\nReturns literal formatted in a sensible way.\nThe fraction part of the number.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe integer part of the number.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe radix prefix, if present.\nWhich radix the literal was represented in.\nThe type suffix, including preceding underscore if present.\nReturns a reasonable digit group size for this radix.\nContains the error value\nContains the success value\nConversion of a value into a <code>Span</code>\nHandle to a range of text in a source file.\nConversion of a value into the range portion of a <code>Span</code>.\nGets the source text.\nAttempts to get the text from the source file. This can …\nChecks if the referenced source text satisfies the given …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nExpand a span to include a preceding comma\nLike <code>snippet_block</code>, but add braces if the expr is not an …\nReturns a new Span that extends the original Span to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the source file, and range in the file, of the given …\nAttempts to get a handle to the source text. Returns <code>None</code> …\nReturns the indentation of the line of a span\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtends the span to the beginning of the spans line, incl. …\nCalls the given function with the both the text of the …\nTakes ownership of the source file handle if the source …\nReturns the position just before rarrow\nReindent a multiline string with possibility of ignoring …\nConverts a span to a code snippet if available, otherwise …\nConverts a span (from a block) to a code snippet if …\nSame as <code>snippet_block</code>, but adapts the applicability level …\nGets a snippet of the indentation of the line of a span\nConverts a span to a code snippet. Returns <code>None</code> if not …\nSame as <code>snippet</code>, but it adapts the applicability level by …\nSame as <code>snippet_with_applicability</code>, but first walks the …\nConverts <code>expr</code> to a <code>char</code> literal if it’s a <code>str</code> literal …\nConverts this into an owned string.\nTrims the whitespace from the start and the end of the …\nTrims the leading whitespace from the range.\nWalks the span up to the target context, thereby returning …\nExtends the range to include all preceding whitespace …\nCalls the given function with the source text referenced …\nCalls the given function with the both the text of the …\nDealing with sting comparison can be complicated, this …\nDealing with sting indices can be hard, this struct …\nGet the indexes of camel case components of a string <code>s</code>\nSplit camel case string into a vector of its components\nReturns index of the first camel-case component of <code>s</code>.\nReturns <code>StrIndex</code> of the last camel-case component of …\nReturns the index of the character after the first …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the number of chars and bytes that match from the …\nReturns the number of chars that match from the start\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a <code>CamelCase</code> version of the input\nReturns a <code>snake_case</code> version of the input\nOperator associativity.\nA binary operator expression, including <code>as</code>-casts and …\nThe operator is both left-associative and …\nSuggestion results for handling closure args dereferencing …\nVisitor struct used for tracking down dereferencing and …\nConvenience extension trait for <code>Diag</code>.\na constant represents an empty string, for convenience.\nThe operator is left-associative.\nAn expression that does not fit in other variants.\nAn expression that never needs parentheses such as <code>1337</code> or …\nThe operator is not associative.\nLiteral constant <code>1</code>, for convenience.\nHelper type to display either <code>foo</code> or <code>(foo)</code>.\nThe operator is right-associative.\nA helper type to build suggestion correctly handling …\nLiteral constant <code>0</code>, for convenience.\nConvenience method to create the <code>&amp;&lt;expr&gt;</code> suggestion.\nConvenience method to create the <code>&amp;*&lt;expr&gt;</code> suggestion. …\nConvenience method to create the <code>&lt;lhs&gt; &amp;&amp; &lt;rhs&gt;</code> suggestion.\nconfidence on the built suggestion\nconfidence on the built suggestion\nConvenience method to create the <code>&lt;lhs&gt; as &lt;rhs&gt;</code> suggestion.\nReturns the associativity/fixity of an operator. The …\nPrepare a suggestion from an expression.\nConverts an <code>ast::BinOp</code> to the corresponding assigning …\nConvenience method to prefix the expression with the <code>async</code> …\nGenerates a string from the operator and both sides.\nConvenience method to create the <code>&lt;lhs&gt; &amp; &lt;rhs&gt;</code> suggestion.\nConvenience method to transform suggestion into a block …\nIndicates if the arg of the closure is a type annotated …\nThe span of the input closure to adapt\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe late context of the lint\nConvenience method to create the <code>*&lt;expr&gt;</code> suggestion.\nBuild suggestion gradually by handling closure arg …\nbuild final suggestion:\nCopied from the rust standard library, and then edited\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nindicates whether the function from <code>parent_expr</code> takes its …\nReturns <code>true</code> if <code>sugg</code> is enclosed in parenthesis.\nConvenience function around <code>hir_opt</code> for suggestions with a …\nGenerate a suggestion for an expression with the given …\nPrepare a suggestion from an expression.\nSame as <code>hir</code>, but it adapts the applicability level by …\nSame as <code>hir</code>, but first walks the span up to the given …\nConverts a <code>hir::BinOp</code> to the corresponding assigning …\nReturns the indentation before <code>span</code> if there are nothing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds the string for <code>&lt;lhs&gt; &lt;op&gt; &lt;rhs&gt;</code> adding parenthesis …\nConvenience wrapper around <code>make_assoc</code> and …\nConvenience method to transform suggestion into a return …\nBuilds the string for <code>&lt;op&gt;&lt;expr&gt;</code> adding parenthesis when …\nAdds parentheses to any expression that might need them. …\nConvenience method to create the <code>&amp;mut &lt;expr&gt;</code> suggestion.\nConvenience method to create the <code>&amp;mut *&lt;expr&gt;</code> suggestion. …\nBuilds a <code>ParenHelper</code>.\nlast position of the span to gradually build the suggestion\n<code>true</code> if parentheses are needed.\nConvenience method to create the <code>&lt;lhs&gt;..&lt;rhs&gt;</code> or …\nSuggests to add an attribute to an item.\nSuggest to add an item before another.\nSuggest to completely remove an item.\ngradually built suggestion\nstarting part of the gradually built suggestion\nThe main thing to display.\nA signature for a function like type.\nHelper to check if given type has inner mutability such as …\nGets the struct or enum variant from the given <code>Res</code>\nGets an iterator over all predicates which apply to the …\nComes up with an “at least” guesstimate for the type’…\nAsserts that the given arguments match the generic …\nChecks whether a type can be partially moved.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWalks into <code>ty</code> and returns <code>true</code> if any inner type is an …\nWalks into <code>ty</code> and returns <code>true</code> if any inner type is an …\nReturns the deref chain of a type, starting with the type …\nIf the expression is function like, get the signature for …\n(ind, size)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nChecks if a Ty&lt;’_&gt; has some inherent method Symbol.\nGets the value of the given variant.\nGet’s the type of a field by name.\nResolves <code>&lt;T as Iterator&gt;::Item</code> for <code>T</code> Do not invoke without …\nGet the diagnostic name of a type, e.g. <code>sym::HashMap</code>. To …\nThis checks whether a given type is known to implement …\nChecks whether this type implements <code>Drop</code>.\nReturns true if ty has <code>iter</code> or <code>iter_mut</code> methods\nChecks whether a type implements a trait. The function …\nSame as <code>implements_trait</code> but allows using a <code>ParamEnv</code> …\nSame as <code>implements_trait_from_env</code> but takes the arguments …\nGets the argument type at the given offset. This will …\nGets the argument type at the given offset. For closures …\nCheck if given type has interior mutability such as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the given type is either <code>core::ffi::c_void</code>, …\nChecks if the given type implements copy.\nCheck if given type has interior mutability such as …\nReturn <code>true</code> if the passed <code>typ</code> is <code>isize</code> or <code>usize</code>.\nChecks if the type is <code>core::mem::ManuallyDrop&lt;_&gt;</code>\nReturns whether <code>ty</code> is never-like; i.e., <code>!</code> (never) or an …\nReturns <code>true</code> if the given type is a non aggregate …\nChecks if <code>Ty</code> is normalizable. This function is useful to …\nReturns <code>true</code> if the given type is a primitive (a <code>bool</code> or …\nChecks if the type is equal to a diagnostic item. To check …\nChecks if the type is equal to a lang item.\nChecks if the type is a reference equals to a diagnostic …\nChecks if a given type looks safe to be uninitialized.\nA fallback for polymorphic types, which are not supported …\nNormalizes the named associated type in the given impl or …\nMakes the projection type for the named associated type in …\nChecks if type is struct, enum or union type with the …\nChecks if the drop order for a type matters.\nReturns ADT variants ordered by size\nGets the result type, if one could be found. Note that the …\nPeels off all references on the type. Returns the …\nAttempts to read the given constant as though it were an …\nReturns <code>true</code> if types <code>a</code> and <code>b</code> are same types having same …\nReturns true if <code>ty</code> is a type on which calling <code>Clone</code> …\nIf the type is function like, get the signature for it.\nA heuristic to tell whether an expression’s type can be …\nReturns <code>true</code> if the given type is an <code>unsafe</code> function.\nReturns the base type for HIR references and pointers.\nReturns the base type for references and raw pointers, and …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTries to tell whether a <code>QPath</code> resolves to something …\nFor at least some <code>QPath::TypeRelative</code>, the path segment’…\nThe type can be determined purely from subexpressions. If …\nThe heuristic believes that more than one <code>DefId</code> applies to …\nDetermining the type requires contextual information.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThink: <code>iter.any(/* is certain */)</code>\nJoin two <code>Certainty</code>s preserving their <code>DefId</code>s (if any). …\nJoin two <code>Certainty</code>s after clearing their <code>DefId</code>s. This …\nThink: <code>iter.all(/* is certain */)</code>\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a set of mutated local variable IDs, or <code>None</code> if …\nAllows for controlled descent when using visitor …\nA type which can be visited.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nreturns <code>true</code> if expr contains match expr desugared from try\nChecks if the given expression contains an unsafe block\nCalls the given function once for each expression …\nCalls the given function once for each expression …\nRuns the given function for each path expression …\nRuns the given function for each path expression …\nRuns the given function for each sub-expression producing …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if the given expression is a constant.\nChecks if the given expression performs an unsafe …\nChecks if the given local is used.\nChecks if the given resolved path is used in the given …\nIf the local is only used once in <code>visitable</code> returns the …\nCalls the corresponding <code>visit_*</code> function on the visitor.\nTrait for visitor functions to control whether or not to …")