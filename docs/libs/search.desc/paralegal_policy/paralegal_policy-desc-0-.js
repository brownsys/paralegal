searchState.loadedDescShard("paralegal_policy", 0, "The query engine and framework for defining paralegal …\nConsider both data and control flow edges in any …\nConfiguration for the framework\nActions that behave differently depending on the context\nConsider only edges with <code>crate::EdgeKind::Control</code>\nConsider only edges with <code>crate::EdgeKind::Data</code>\nProvide display trait for DefId in a Context.\nWhich type of edges should be considered for a given …\nThe type identifying a function that is used in call sites.\nA globally identified node in an SPDG\nA path to a <code>ProgramDescription</code> file from which a <code>Context</code> …\nThis lets us be agnostic whether a primitive (such as …\nThe iterator returned by <code>Self::iter_nodes</code>\nIdentifier for a graph element that allows attaching a …\nUser-defined PDG markers.\nCollection of entities a particular marker has been …\nExtension trait with queries for single nodes\nContext queries conveniently accessible on nodes\nResult of running a policy\nThe annotated program dependence graph.\nInterface for defining policies.\nConfiguration of the <code>cargo paralegal-flow</code> command.\nStatistics about the runtime of the various parts of a …\nAbort compilation once the analysis artifacts have been …\nAlgorithms for querying the graph\nGather all <code>CallString</code>s that are mentioned in this program …\nGather all data sources that are mentioned in this program …\nHow much information to retain for error messages in …\nRuntime of the <code>paralegal-flow</code> command\nCheck the condition and emit a <code>Diagnostics::error</code> if it …\nCheck the condition and emit a <code>Diagnostics::warning</code> if it …\nFind the call string for the statement or function that …\nRead and parse this graph file, returning a <code>Context</code> …\nRead <code>self</code> using the configured serialization format\nWrite <code>self</code> using the configured serialization format\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIs this edge kind admissible?\nHow long it took to create the indices\nThe controller id all of these nodes are located in.\nThe identifier for the SPDG this node is contained in\nEntry points we analyzed and their PDGs\nContext for the DefId.\nUse a completely custom path (directory and file name).\nUse a custom binary or base invocation as command.\nDefId to display.\nMetadata about the <code>DefId</code>s\nReturns a DisplayNode for the given Node\nHow long it took to read in the graph description\nEmit messages to the user running a policy.\nA convenience method for gathering multiple node(cluster)s …\nPass the provided file as <code>--external-annotations</code> to the …\nCreate a graph adaptor that implements this edge selection.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new globally identified node by pairing a node …\nMutably borrow the command to perform further …\nGet the span of a node\nUse a global installation of <code>paralegal-flow</code> via …\nReturns whether this Node has the marker applied to it …\nReturns whether this Node has the marker applied to it …\nReturns true if this node has the provided type\nRetrieve metadata about a node.\nRetrieve metadata about the instruction executed by a …\nMetadata about the instructions that are executed at all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the enum is EdgeSelection::Both otherwise …\nReturns true if the enum is EdgeSelection::Control …\nReturns true if the enum is EdgeSelection::Data otherwise …\nIterate all nodes as globally identified one’s.\niterate over the local nodes\nA convenience macro that uses <code>file!</code>, <code>line!</code> and <code>column!</code> to …\nThe local node in the SPDG\nReturns an iterator over all objects marked with <code>marker</code>.\nAll nodes with this marker, be that via type or directly\nAll nodes that have this marker through a type\nGet a node from this cluster. No guarantees are made as to …\nInspect the path that will be loaded\nHow long the policy runs\nReturn the immediate predecessors of this node\nIf the policy wants to return additional data, this is it\nGet the root context object\nConsume the created command and execute it in the …\nThe shortest path between this and a target node\nRuntime statistics\nGet the path where the analyzzer wrote statistics to. Use …\nUse the default graph file name in the specified directory.\nDid the policy succeed.\nReturn the immediate successors of this node\nCollect the iterator into a cluster\nMetadata about types\nGet the type(s) of a Node.\nCreate a new node with no guarantee that it exists in the …\nDoes this selection admit edges of type …\nDoes this selection admit edges of type …\nWhether tho precompute an index for <code>flows_to</code> queries with …\nBuilds a context, then runs the property.\nBuilds a context, then runs the property.\nChecking always-happens-before relationships\nPrecomputed reachability queries\nStatistics about the result of running …\nKeep full violating paths\nDon’t trace paths, only remember number of violating …\nRemember start and end nodes for violating paths\nRetention level of additional information about the …\nFails if <code>Self::holds</code> is false.\nHow many paths lead to the checkpoints?\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFormat the results of this combinator, using the <code>def_info</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if the property that created these statistics …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>true</code> if this policy applied to no paths. E.g. either no …\nIf the trace level is sufficient, return the pairing of …\nHow many paths terminated at the end?\nCheck this property holds and report it as diagnostics in …\nHow large was the set of initial nodes this traversal …\nPrecomputed indices for common queries of a PDG.\nAn <code>Iterator</code> over the <code>SPDGNode</code>s from the given src in the …\nConstructs the transitive closure from a <code>SPDG</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe densely packed transitive closure of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new iterator that iterates through nodes that …\nActions that behave differently depending on the context\nProvide display trait for DefId in a Context.\nThe type identifying a function that is used in call sites.\nIdentifier for a graph element that allows attaching a …\nUser-defined PDG markers.\nCollection of entities a particular marker has been …\nExtension trait with queries for single nodes\nContext queries conveniently accessible on nodes\nInterface for defining policies.\nIterate over all defined controllers\nReturns all nodes that are in any of the PDGs\nReturns all DataSources, DataSinks, and CallSites for a …\nEnforce that on every data flow path from the …\nReturn an example pair for a flow from an source from <code>from</code> …\nFind the call string for the statement or function that …\nFind the call string for the statement or function that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCall sites that consume this node directly. E.g. the …\nCall sites that consume this node directly. E.g. the …\nCall sites that consume this node directly. E.g. the …\nFind the node that represents the <code>index</code>th argument of the …\nFind a singular controller with this name.\nIterate over all defined controllers as contexts\nFind all controllers that bare this name.\nContext for the DefId.\nDefId to display.\nReturns the input <code>ProgramDescription</code>.\nReturns a DisplayNode for the given Node\nReturns a DisplayDef for the given def_id\nReturns a DisplayNode for the given Node\nDispatch and drain all queued diagnostics without aborting …\nDispatch and drain all queued diagnostics, aborts the …\nFind all types, controllers and functions with this name.\nFind a type, controller or function id by its name.\nFind a type, controller or function with this path.\nReturns whether there is direct control flow influence …\nReturns whether there is direct control flow influence …\nReturns the sink node that is reached\nReturns the sink node that is reached\nReturns whether a node flows to a node through the …\nReturns whether a node flows to a node through the …\nReturns whether a node flows to a node through the …\nAn optimized version of the following pattern that …\nAn optimized version of the following pattern that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the span of a node\nGet the span of a node\nGet the type(s) of a Node.\nReturns whether there is direct control flow influence …\nReturns whether there is direct control flow influence …\nReturns whether there is direct control flow influence …\nSimilar to <code>Self::has_ctrl_influence</code> but checks that all …\nSimilar to <code>Self::has_ctrl_influence</code> but checks that all …\nReturns whether this Node has the marker applied to it …\nReturns whether the given Node has the marker applied to …\nReturns true if this node has the provided type\nReturns iterator over all Nodes that are influenced by the …\nReturns iterator over all Nodes that are influenced by the …\nReturns iterator over all Nodes that are influenced by the …\nReturns iterator over all Nodes that influence the given …\nReturns iterator over all Nodes that influence the given …\nReturns iterator over all Nodes that influence the given …\nRetrieve metadata about a node.\nReturn which data is being read from for the modification …\nRetrieve metadata about the instruction executed by a …\nRetrieve metadata about the instruction executed by a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over all objects marked with <code>marker</code>.\nReturn all types that are marked with <code>marker</code>\nNest another named combinator into the diagnostic context.\nRun the computation in the diagnostic context of this …\nAdd a policy to the diagnostic context.\nConstruct a <code>Context</code> from a <code>ProgramDescription</code>.\nRetrieve metadata about a node.\nList of graph nodes marked with a particular marker\nAll nodes with this marker, be that via type or directly\nAll nodes that have this marker through a type\nReturns all the type alias annotation for a given type\nReturn which data is being written to at this location\nReturn the immediate predecessors of this node\nReturn the immediate predecessors of this node\nRecord a diagnostic message.\nEmit a warning if this marker was not found in the source …\nGet the root context object\nReturns an iterator over all nodes that do not have any …\nReturn nodes that satisfy the predicate and which have no …\nThe shortest path between this and a target node\nGet other nodes at the same instruction\nGet other nodes at the same instruction\nReturns an iterator over the data sources within …\nReturn the immediate successors of this node\nReturn the immediate successors of this node\nGet the type(s) of a Node.\nList of types marked with a particular marker\nA context for combinators.\nA context for controllers\nRepresentation of a diagnostic message. You should not …\nFacility to create structured diagnostics including spans …\nContext provided to <code>HasDiagnosticsBase::record</code>.\nUser-facing methods to emit diagnostics.\nBase database of emitted diagnostics.\nThis indicates that the policy failed.\nLow level machinery for diagnostics.\nSome helpful hint\nA span with only a portion highlighted.\nAdditional information for a diagnostic\nA context for a named policy.\nSeverity of a recorded diagnostic message\nThis could indicate that the policy does not operate as …\nAccess to <code>Context</code>, usually also available via …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIterate over all defined controllers as contexts\nAccess the current controller contents\nQueue the diagnostic for display to the user.\nEmit queued diagnostics, draining the internal queue of …\nEmit a message that is severe enough that it causes the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEmit a message that suggests something to the user.\nAccess the id for the controller of this context\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd a named combinator to the diagnostic context.\nAdd a named combinator to the diagnostic context.\nNest another named combinator into the diagnostic context.\nRun the computation in the diagnostic context of this …\nAdd a policy to the diagnostic context.\nCreate a  new span with a highlighted section\nEmit an error, failing the policy, with the span of a …\nEmit a help message with the span of a graph node.\nEmit a note with the span of a graph node.\nEmit an warning, that does not fail the policy, with the …\nEmit a message that provides additional information to the …\nBase function for recording new diagnostics.\nEmit a message that is severe enough that it causes the …\nEmit a message that suggests something to the user.\nEmit a message that provides additional information to the …\nEmit a message that indicates to the user that the policy …\nInitialize a diagnostic builder for an error.\nInitialize a diagnostic builder for a help message.\nInitialize a diagnostic builder for an error with the span …\nInitialize a diagnostic builder for an help message with …\nInitialize a diagnostic builder for an note with the span …\nInitialize a diagnostic builder for an error with the span …\nInitialize a diagnostic builder for a note\nInitialize a diagnostic builder for an error with a source …\nInitialize a diagnostic builder for a help message with a …\nInitialize a diagnostic builder for a note with a source …\nInitialize a diagnostic builder for a warning with a …\nInitialize a diagnostic builder for a warning.\nEmit a message that indicates to the user that the policy …\nAppend a help message to the diagnostic.\nAppend a help message and the span of a graph node to the …\nAppend a note and the span of a graph node to the …\nAppend a warning with a source code span to the diagnostic.\nAppend a note to the diagnostic.\nAppend a help message with a source code span to the …\nAppend a note with a source code span to the diagnostic.\nAppend a warning and the span of a graph node to the …\nAppend a warning to the diagnostic.")